1
00:00:06,109 --> 00:00:09,240
Если мы говорим о текстовых данных, то стандартная задача --

2
00:00:09,240 --> 00:00:12,879
это поиск текста.

3
00:00:12,879 --> 00:00:25,939
А по сути, это две отдельные задачи -- найти какой-то текст внутри файла или текстового потока

4
00:00:25,939 --> 00:00:37,710
и найти файл, например, по имени в каких-то каталогах.

5
00:00:37,710 --> 00:00:55,580
Для первой задачи у нас есть утилита grep,
 которая выводит строки, соответствующие шаблону.

6
00:00:55,580 --> 00:00:57,980
$ man grep

7
00:00:57,980 --> 00:01:09,350
В качестве шаблона можно использовать как фиксированные строки,

8
00:01:09,350 --> 00:01:12,060
так и регулярные выражения.

9
00:01:12,060 --> 00:01:14,860
Также вы можете выполнять рекурсивный поиск.

10
00:01:14,860 --> 00:01:26,159
Другая часто используемая команда -- это `find` --
 поиск файлов в иерархии каталогов.

11
00:01:26,159 --> 00:01:27,840
$ man find

12
00:01:27,840 --> 00:01:40,760
Вы должны установить начальную точку для поиска -- каталог

13
00:01:40,760 --> 00:01:50,340
или несколько каталогов

14
00:01:50,340 --> 00:01:56,490
и выражения с критериями поиска и действиями.

15
00:01:56,490 --> 00:02:05,030
Вы можете искать по имени с использованием стандартных
 шаблонов соответствия shell, по времени модификации

16
00:02:05,030 --> 00:02:12,060
или времени доступа, по размеру, по пользователю и группе,
 по разрешениям, типу файла и т.д.

17
00:02:12,060 --> 00:02:21,920
Вы можете использовать в выражениях
 логические операторы, такие как «и», «или» и «не».

18
00:02:21,920 --> 00:02:29,340
Также вы можете выполнить некоторые действия,
 когда найдете что-то, что соответствует критериям.

19
00:02:29,340 --> 00:02:33,120
Действие по умолчанию -- `print` (печать).

20
00:02:33,120 --> 00:02:43,200
Вы также можете использовать форматированную печать,
 список найденных файлов, удалять их

21
00:02:43,200 --> 00:02:44,550
и выполнять команды с ними.

22
00:02:44,550 --> 00:02:54,900
В действиях `exec` вы можете использовать
 фигурные скобки для вставки имени найденного файла.

23
00:02:54,900 --> 00:03:06,030
Но имейте в виду -- вы должны заканчивать свою команду точкой с запятой,
 и, чтобы избежать интерпретации этого символа

24
00:03:06,030 --> 00:03:17,010
вашим Shell, вы должны экранировать его с помощью '\'.

25
00:03:17,010 --> 00:03:25,349
К сожалению, основным недостатком `find` является
 долгое время выполнения, особенно если вы просматриваете

26
00:03:25,349 --> 00:03:27,030
большие каталоги с глубокой вложенностью.

27
00:03:27,030 --> 00:03:33,300
А чтобы ускорить этот процесс, вы можете использовать утилиту `locate`.

28
00:03:33,300 --> 00:03:57,690
Он находит файлы по имени из баз данных,
 подготовленных `updatedb`, и делает это довольно быстро.

29
00:03:57,690 --> 00:04:06,180
Но вы должны понимать -- `updatedb`
 автоматически запускается сервисом `cron` ночью.

30
00:04:06,190 --> 00:04:13,760
И если вы устанавливаете только инструментарий `lookup`
 или хотите найти что-то в измененной файловой системе в этот момент,

31
00:04:13,760 --> 00:04:19,999
вам необходимо обновить эту базу данных вручную, запустив `updatedb`.

32
00:04:19,999 --> 00:04:22,840
ОК.

33
00:04:22,840 --> 00:04:30,119
Еще одна операция, которая нам часто требуется --
 это сравнение файлов или каталогов.

34
00:04:30,119 --> 00:04:33,459
И у нас есть для этого инструменты.

35
00:04:33,459 --> 00:04:35,960
$ man cmp

36
00:04:35,960 --> 00:04:44,150
Утилита `cmp` сравнивает два файла побайтно

37
00:04:44,150 --> 00:04:48,129
и сообщает позицию, с которой у нас есть разница.

38
00:04:48,129 --> 00:04:52,669
Таким образом мы можем сравнивать двоичные файлы.

39
00:04:52,669 --> 00:04:59,659
Для сравнения текстовых файлов можно использовать утилиту `diff`:

40
00:04:59,659 --> 00:05:00,659
$ man diff

41
00:05:00,659 --> 00:05:02,849
Мы можем сравнивать файлы и каталоги

42
00:05:02,849 --> 00:05:06,009
при помощи опции `-r | --recursive`.

43
00:05:06,009 --> 00:05:20,509
Мы можем получить результат в виде набора команд
 для строкового редактора `ed` или утилиты `patch`.

44
00:05:20,509 --> 00:05:29,680
Этот метод передачи изменений при разработке проектов

45
00:05:29,680 --> 00:05:39,169
в экосистеме UNIX исторически был первым, просто чтобы уменьшить объем отправляемых данных. И он продолжает использоватся и по сей день.

46
00:05:39,169 --> 00:05:56,979
Еще одна важная операция при работе с текстовыми данными --
 это сортировка, и у нас есть утилита `sort`,

47
00:05:56,979 --> 00:05:59,879
которая сортирует строки текстовых файлов:

48
00:05:59,879 --> 00:06:01,960
$ man sort

49
00:06:01,960 --> 00:06:17,379
Для устранения повторяющихся строк у нас есть утилита `uniq`,
 но сначала мы должны отсортировать

50
00:06:17,379 --> 00:06:22,399
наш текстовый поток для такой унификации:

51
00:06:22,399 --> 00:06:34,569
$ sort file | uniq

52
00:06:34,569 --> 00:06:43,369
Мы можем вывести начало/конец файла с помощью утилит `head` и` tail`.

53
00:06:43,369 --> 00:06:51,732
По умолчанию они помещают в стандартный вывод
 первые или последние 10 строк стандартного ввода

54
00:06:51,732 --> 00:06:57,729
или файла, указанного в качестве аргумента.

55
00:06:57,729 --> 00:07:07,329
Вы можете установить другое количество строк в качестве параметров:

56
00:07:07,329 --> 00:07:11,389
$ tail -15

57
00:07:11,389 --> 00:07:16,610
Также в `tail` вы можете использовать опцию `-f | --follow`

58
00:07:16,610 --> 00:07:21,979
для отображения добавляемых данных по мере роста файла.

59
00:07:21,979 --> 00:07:27,469
Это очень полезно для отслеживания файлов журналов.

60
00:07:27,469 --> 00:07:44,860
Более того, из текстовых строк можно вырезать
 некоторые поля, разделенные какими-то разделителями,

61
00:07:44,860 --> 00:07:48,410
с помощью утилиты `cut`.

62
00:07:48,410 --> 00:08:00,569
Также вы можете объединить строки двух файлов
 по общему полю с помощью утилиты `join`

63
00:08:00,569 --> 00:08:04,369
и объединить строки файлов с помощью `paste`.

64
00:08:04,369 --> 00:08:08,309
И, наконец, у нас есть `awk`.

65
00:08:08,309 --> 00:08:13,039
$ man awk

66
00:08:13,039 --> 00:08:33,070
Это язык сканирования и создания шаблонов,
 который может выполнять эту и другую сложную работу

67
00:08:33,070 --> 00:08:34,129
с текстовыми файлами или потоками.

