1
00:00:07,120 --> 00:00:10,200
Перейдем к следующему тегу:

2
00:00:10,200 --> 00:00:26,100
$ git checkout Example_3
$ git diff Example_2 Example_3

3
00:00:26,100 --> 00:00:26,600
Как видите, файлы были изменены:

4
00:00:26,600 --> 00:00:45,469
README и наш скрипт `calc`.

5
00:00:45,469 --> 00:00:47,920
Посмотрим на `calc`:

6
00:00:47,920 --> 00:00:56,360
$ cat calc

7
00:00:56,379 --> 00:01:01,859
Выглядит посложнее -- давайте проанализируем

8
00:01:01,859 --> 00:01:03,339
изменения.

9
00:01:03,339 --> 00:01:18,840
Итак, основная идея исправлений состоит в том, чтобы прочитать
 выражение из стандартного ввода, а не из параметров скрипта,

10
00:01:18,840 --> 00:01:26,330
и изменить его, чтобы убрать влияние механизма сопоставления Shell.

11
00:01:26,330 --> 00:01:27,690
OK.

12
00:01:27,690 --> 00:01:39,970
В третьей строке мы определяем переменную FILE
 с уникальным именем для хранения временных данных

13
00:01:39,970 --> 00:01:42,280
для вычисления `expr`.

14
00:01:42,280 --> 00:01:53,610
Уникальность гарантируется специальной переменной среды --
 $$, которая возвращает

15
00:01:53,610 --> 00:01:57,530
PID текущего процесса.

16
00:01:57,530 --> 00:02:09,280
В пятой строке мы считываем выражение из stdin в переменную EXPR.

17
00:02:09,280 --> 00:02:19,650
Затем мы редактируем его на лету с помощью редактора потока `sed`.

18
00:02:19,650 --> 00:02:36,450
С помощью команды `sed` мы вставляем пробелы
 между числами и знаками арифметических операций,

19
00:02:36,450 --> 00:02:45,519
мы выполняем экранирование с помощью
 символа косой черты перед звездочкой и скобками.

20
00:02:45,519 --> 00:02:55,680
Наконец, перед выражением вставляем команду `expr`
 и перенаправляем вывод `sed`

21
00:02:55,680 --> 00:03:04,610
во временный файл, определенный в начале скрипта.

22
00:03:04,610 --> 00:03:19,080
Затем мы запускаем наш временный скрипт с помощью `sh`,
 получая статус выхода из специальной переменной $?

23
00:03:19,080 --> 00:03:24,440
в переменную EXIT_STATUS, удаляя временный файл и осуществляя выход

24
00:03:24,440 --> 00:03:37,140
с параметрами, хранящимися в EXIT_STATUS.

25
00:03:37,140 --> 00:03:43,380
Нам нужна такая сложная конструкция,
 потому что `rm -rf` вернет статус успеха

26
00:03:43,380 --> 00:03:55,950
независимо от результата вычисления выражения.

27
00:03:55,950 --> 00:04:02,779
ОК -- проверим наши исправления:

28
00:04:02,779 --> 00:04:08,520
$ ./calc
2*2
4

29
00:04:08,529 --> 00:04:12,379
Работает!

30
00:04:12,379 --> 00:04:23,150
И нам даже не нужно вставлять пробелы между частями нашего выражения.

31
00:04:23,150 --> 00:04:29,309
Проверим -- может, наши исправления что-то еще сломали?

32
00:04:29,309 --> 00:04:30,550
$ ./calc

33
00:04:30,550 --> 00:04:33,029
1+2
3

34
00:04:33,029 --> 00:04:35,520
$ ./calc
5-7
-2

35
00:04:35,520 --> 00:04:38,000
$ ./calc
6/3
2

36
00:04:40,490 --> 00:04:42,970
$ ./calc
7/3
2

37
00:04:42,970 --> 00:04:45,449
$ ./calc
7%3
1

38
00:04:55,389 --> 00:04:56,629
$ ./calc
6/0
expr: division by zero

39
00:04:56,629 --> 00:04:59,540
$ echo $?
2

40
00:04:59,540 --> 00:05:14,280
Ну что ж, недурно. Получили ожидаемую ошибку -- деление на ноль!

41
00:05:14,280 --> 00:05:18,360
Конечно, мы можем реализовать более простое решение

42
00:05:18,360 --> 00:05:47,069
в шестой строке без помощи черной магии sed, просто написав:

43
00:05:47,069 --> 00:06:11,539
echo $(($EXPR)) > $FILE

44
00:06:11,539 --> 00:06:15,299
Но мы написали сценарий, который будет работать

45
00:06:15,299 --> 00:06:22,159
со старыми оболочками, которые могут не поддерживать
 такие конструкции, и мы также рассмотрели, как использовать

46
00:06:22,159 --> 00:06:29,629
неинтерактивное редактирование в скриптах.

