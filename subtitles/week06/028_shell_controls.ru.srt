1
00:00:05,400 --> 00:00:17,010
Итак, у нас есть скрипты с аргументами, но как насчет логики?
 У нас есть кое-какие операции, которые играют роль как бы логических,

2
00:00:17,010 --> 00:00:31,109
 но на первый взгляд выглядят несколько необычно.
 Собственно, краеугольным камнем

3
00:00:31,109 --> 00:00:45,560
логики Shell является эта странноватая зарезервированная переменная:

4
00:00:45,560 --> 00:00:49,360
$? - это возвращаемое значение последней запущенной команды.

5
00:00:49,360 --> 00:00:56,600
Например, у нас есть следующие команды:

6
00:00:56,600 --> 00:01:00,530
$ true; echo $?
0

7
00:01:00,530 --> 00:01:08,380
$ false; echo $?
1

8
00:01:08,390 --> 00:01:21,030
Что это значит? Только одно --
 у нас есть программа с успешным кодом выхода 0

9
00:01:21,030 --> 00:01:37,070
и сбойная с ненулевым кодом выхода. На первый взгляд
 это кажется странным, но на самом деле всё понятно --

10
00:01:37,070 --> 00:01:50,950
UNIX следует принципу Льва Толстого:
 «Все счастливые семьи похожи друг на друга, каждая несчастливая

11
00:01:50,950 --> 00:02:03,340
семья несчастна по-своему». И в самом деле -- нас не интересуют

12
00:02:03,340 --> 00:02:14,920
 детали того, когда наша программа успешно завершилась,
 но причины сбоя могут быть самые различные,

13
00:02:14,920 --> 00:02:20,200
и мы должны иметь возможность отделить одну от другой.

14
00:02:20,200 --> 00:02:30,279
И если у нас есть успешные и неудачные результаты,
 мы можем работать с этими результатами,

15
00:02:30,279 --> 00:02:39,469
используя операции, аналогичные логическим операторам AND и OR:

16
00:02:39,469 --> 00:02:56,170
* prog1 && prog2 -- означает запуск prog2,
 если prog1 завершается успешно (с 0 кодом выхода)

17
00:02:56,170 --> 00:03:13,590
* prog1 || prog2 -- означает запуск программы prog2
 в случае сбоя программы prog1 (выход с кодом, отличным от 0)

18
00:03:13,590 --> 00:03:21,950
ОК. Также в нашем языке программирования есть старый добрый "if" (если).

19
00:03:28,859 --> 00:03:37,099
И что это за “list” (список) в данном случае?
 Это всего лишь команда.

20
00:03:37,099 --> 00:03:45,000
Код выхода команды будет определять поведение `if`.

21
00:03:45,000 --> 00:04:03,000
И в теле нашего 'if' мы можем запускать другие команды,
 которые также названы “list”.

22
00:04:03,000 --> 00:04:08,560
И наиболее часто используемая команда в `if` -- это команда `test`

23
00:04:08,569 --> 00:04:26,900
или просто открывающая квадратная скобка
 (часто это просто ссылка на исполняемый файл `test`).

24
00:04:26,900 --> 00:04:41,080
Имейте в виду, что если вы используете квадратную скобку,
 вы должны закрыть выражение

25
00:04:41,080 --> 00:04:54,560
закрывающей квадратной скобкой. И пробел
 перед ним важен, потому что это просто

26
00:04:54,560 --> 00:04:58,660
аргумент команды.

27
00:04:58,660 --> 00:05:14,440
ОК. Мы также можем видеть выражения,
 которые проверяют строку или переменную:

28
00:05:14,440 --> 00:05:24,100
нулевой она длинны или нет.

29
00:05:24,100 --> 00:05:34,920
Операция НЕ обозначается как "!", логические операции И, ИЛИ.

30
00:05:34,920 --> 00:05:55,900
Сравнение строк. И, как мы видим, сравнение чисел похоже
 на старые добрые операции сравнения Фортрана.

31
00:05:55,900 --> 00:06:07,940
Некоторые проверяют наличие файлов, каталогов, символических ссылок

32
00:06:07,949 --> 00:06:08,949
и многое другое.

33
00:06:08,949 --> 00:06:22,229
У нас также есть операторы цикла -- `while`,

34
00:06:22,229 --> 00:06:33,120
которые выполняют команды,
 в то время как команда условия возвращает 0 и` until`,

35
00:06:33,129 --> 00:06:39,040
выполняясь до тех пор, пока команда условия завершается ошибкой.

36
00:06:39,059 --> 00:06:45,539
У нас также есть конструкция цикла `for`,

37
00:06:45,539 --> 00:06:57,760
 которая может показаться не очень привычной тем, кто программировал
 на классических языках программирования, таких как C.

38
00:06:57,770 --> 00:07:01,979
Источником значений, которые устанавливаются

39
00:07:01,979 --> 00:07:12,220
для переменной цикла, является просто строка слов,
 разделенных пробелами. Чтобы имитировать классические

40
00:07:12,220 --> 00:07:20,370
числовые циклы, мы должны использовать специальные команды,
 которые будут генерировать для нас последовательности чисел.

41
00:07:20,370 --> 00:07:27,270
Как команда `seq`:

42
00:07:50,200 --> 00:07:51,300
Как эта

43
00:08:06,500 --> 00:08:12,000
последовательность от 1 до 10 с шагом 2.

44
00:08:12,000 --> 00:08:16,180
Также

45
00:08:16,199 --> 00:08:28,499
вы можете использовать классические операторы цикла
 "break" и "continue" с возможностью установки уровня

46
00:08:28,499 --> 00:08:35,080
для прерывания или продолжения вашего цикла.

47
00:08:35,080 --> 00:08:44,320
Команда `case` сначала интерпретирует слово и пытается

48
00:08:44,320 --> 00:08:58,030
сопоставить его с каждым шаблоном по очереди,
 используя те же метасимволы,

49
00:08:58,030 --> 00:09:01,320
что и для имён файлов/каталогов.

50
00:09:01,320 --> 00:09:08,170
Если используется оператор «двойная точка с запятой»,

51
00:09:08,170 --> 00:09:18,200
после первого сопоставления с образцом попытки последующих сопоставлений не предпринимаются. Как и в языке Си.

52
00:09:18,200 --> 00:09:22,480
Попробуем еще раз поиграть с нашей программой `hello`.

53
00:11:24,900 --> 00:11:27,434
ОК

