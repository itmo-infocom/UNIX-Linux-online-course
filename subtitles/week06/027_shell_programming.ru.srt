1
00:00:06,759 --> 00:00:13,559
Пришло время приступить к программированию, программированию на Shell.

2
00:00:13,559 --> 00:00:22,570
Насколько мы понимаем, shell работает
 как обычная программа и имеет несколько опций,

3
00:00:22,570 --> 00:00:27,550
которые могут быть полезны для отладки:

4
00:00:27,550 --> 00:00:39,660
-v -- печатает строки ввода оболочки по мере их чтения.

5
00:00:39,660 --> 00:00:48,530
-x -- печатает команды и их аргументы по мере их выполнения.

6
00:00:48,530 --> 00:01:04,439
и, наконец, "-c" и какая-то строка -- читать и выполнять команды
 из этой строки после обработки параметров, затем выйти.

7
00:01:04,439 --> 00:01:11,460
Если ваша оболочка -- Bash, вам могут помочь такие команды:

8
00:01:11,460 --> 00:01:14,400
$ bash -c help
$ bash -c 'help set'

9
00:01:14,400 --> 00:01:25,200
И, конечно же, вы можете прочитать справочную страницу о вашей оболочке.

10
00:01:25,200 --> 00:01:35,540
Давайте следовать доброй традиции,
 начатой ​​классической книгой Кернигана и Ричи

11
00:01:35,540 --> 00:01:40,730
"Язык программирования C", и напишем стандартную программу "Hello World":

12
00:01:40,730 --> 00:01:58,460
$ cat> hello
echo Hello word
^D

13
00:01:58,470 --> 00:02:07,460
Мы завершаем ввод с помощью EOF (символ Ctrl-D).

14
00:02:07,479 --> 00:02:10,289
Теперь попробуем запустить:

15
00:02:10,289 --> 00:02:16,889
$ sh hello
Hello word

16
00:02:16,889 --> 00:02:18,540
Хорошо.

17
00:02:18,540 --> 00:02:25,290
А теперь давайте превратим наш скрипт
 в настоящую исполняемую программу:

18
00:02:25,290 --> 00:02:31,379
$ chmod +x hello

19
00:02:31,379 --> 00:02:39,480
$ ./hello
Hello word

20
00:02:39,489 --> 00:02:47,230
Отлично! Теперь поговорим об аргументах.

21
00:02:47,230 --> 00:02:52,830
Давайте посмотрим на наш первый позиционный параметр:

22
00:02:52,830 --> 00:03:07,930
$ vi hello
echo Hello $1

23
00:03:07,930 --> 00:03:13,970
$ ./hello
Hello

24
00:03:13,970 --> 00:03:18,749
Мы вызвали наш скрипт без параметров

25
00:03:18,749 --> 00:03:21,260
и получили то, что попросили.

26
00:03:21,260 --> 00:03:24,549
Давайте добавим какой-нибудь параметр:

27
00:03:24,549 --> 00:03:31,310
$ ./hello world
Hello world

28
00:03:31,310 --> 00:03:35,849
Но для некоторых параметров это не работает:

29
00:03:35,849 --> 00:03:43,280
$ ./hello world and universe
Hello world

30
00:03:43,299 --> 00:03:44,919
Давайте исправим:

31
00:03:44,919 --> 00:03:49,659
$ vi hello
echo Hello $ *

32
00:03:49,659 --> 00:03:59,139
$ ./hello world and universe
Hello world and universe

33
00:03:59,139 --> 00:04:00,329
Отлично!

34
00:04:00,329 --> 00:04:15,559
Как мы видим, между разными оболочками
 существует некоторая разница в использовании

35
00:04:15,559 --> 00:04:22,260
некоторых специальных имен переменных, связанных с параметрами скрипта.

36
00:04:22,260 --> 00:04:31,540
Мы имеем разные стили использования параметров в Bourne-Shell и C-Shell.

37
00:04:31,540 --> 00:04:38,660
Основным преимуществом новых shell'ов

38
00:04:38,660 --> 00:04:53,260
 перед классическим Bourne Shell является
 возможность использования более 9 параметров.

39
00:04:53,260 --> 00:05:03,150
Ведь в Bourne Shell у нас есть только одна цифра для номера параметра.

40
00:05:03,150 --> 00:05:10,170
В более новых оболочках мы можем использовать
 более длинные числа, используя квадратные скобки.

41
00:05:10,170 --> 00:05:27,170
Очень важная вещь в мире UNIX -- это позиционный
 параметр с нулевым номером.

42
00:05:27,170 --> 00:05:32,930
Давайте посмотрим:

43
00:05:32,930 --> 00:05:40,930
$ vi hello
echo \$0: $0
echo Hello $*

44
00:05:40,930 --> 00:05:50,520
$ ./hello
$0: ./hello
Hello

45
00:05:50,530 --> 00:05:55,510
Нулевой параметр -- это просто имя скрипта.

46
00:05:55,510 --> 00:06:17,080
А если вы знакомы с языком C, то наверняка знаете -- это же самое и в argv[0].

47
00:06:17,080 --> 00:06:22,990
Для каких нужд можно использовать такой параметр?

48
00:06:22,990 --> 00:06:39,780
Самый очевидный ответ -- написать красивое сообщение
 об ошибке при использовании нашего скрипта.

49
00:07:23,120 --> 00:07:27,700
Мы получим некоторую подсказку по тому, как вызывать нашу программу.

50
00:07:27,710 --> 00:07:34,740
Но в UNIX-подобных системах мы можем использовать

51
00:07:34,740 --> 00:07:39,670
очень интересный прием -- линкование файлов.

52
00:07:39,670 --> 00:07:52,090
Взгляните на этот супер-нано-ноутбук.

53
00:07:52,090 --> 00:08:08,210
Он работает на OpenWRT, дистрибутиве Linux,
 который вы можете найти, например,

54
00:08:08,210 --> 00:08:09,210
на своем домашнем интернет-маршрутизаторе.

55
00:08:09,210 --> 00:08:17,460
У нас есть полностью функциональный набор утилит Linux,
 но если мы присмотримся внимательнее, то увидим,

56
00:08:17,460 --> 00:08:28,580
что все обычные утилиты UNIX представляют собой
 просто символические ссылки на один бинарный файл -- "busybox".

57
00:08:28,580 --> 00:08:34,440
# ls -l /bin

58
00:08:34,440 --> 00:08:38,460
Busybox просто смотрит на имя, под которым он запущен,

59
00:08:38,460 --> 00:08:46,070
и выполняет соответствующие функции из библиотеки busybox.

60
00:08:46,070 --> 00:08:53,980
Этот метод позволяет снизить потребление памяти встроенной системой.

61
00:08:53,980 --> 00:08:59,120
Попробуем использовать эту функцию в нашем скрипте:

62
00:08:59,120 --> 00:09:02,760
$ vi hello

63
00:09:02,760 --> 00:09:24,600
if [$ # -lt 1]
then
 echo Usage: $0 who...
 exit
fi
echo $0 $*

64
00:09:24,600 --> 00:09:35,520
$ ln -sf hello bye

65
00:09:35,520 --> 00:09:42,800
$ ./hello world
./hello world

66
00:09:42,800 --> 00:09:46,140
$ ./bye bye
./bye bye

67
00:09:46,140 --> 00:09:46,640
Вуаля!

