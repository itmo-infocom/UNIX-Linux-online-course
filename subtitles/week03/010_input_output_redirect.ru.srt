1
00:00:06,609 --> 00:00:16,059
Стандартный шаблон проектирования для команд UNIX --
это чтение информации из стандартного входного потока

2
00:00:16,059 --> 00:00:25,850
(по умолчанию -- клавиатура текущего терминала)
и запись в стандартный вывод

3
00:00:25,850 --> 00:00:35,640
(по умолчанию -- экран терминала), а также
перенаправление ошибок в стандартный поток ошибок 

4
00:00:35,640 --> 00:00:45,440
(также экран терминала), если в
параметрах команды не указано иное.

5
00:00:45,440 --> 00:00:51,570
Эти настройки по умолчанию могут быть изменены в Shell.

6
00:00:51,570 --> 00:01:03,680
Команда заканчивается знаком «больше»,
 а имя файла означает перенаправление

7
00:01:03,680 --> 00:01:07,310
стандартного вывода в этот файл.

8
00:01:07,310 --> 00:01:17,170
Код приложения не меняется, но данные,
которые оно отправляет на экран,

9
00:01:17,170 --> 00:01:20,249
будут направлены в этот файл.

10
00:01:20,249 --> 00:01:32,029
А команда, заканчивающаяся знаком «меньше»
 и именем файла, означает перенаправление

11
00:01:32,029 --> 00:01:38,340
стандартного ввода из этого файла.

12
00:01:38,340 --> 00:01:47,649
Все данные, которые приложение ожидает
с клавиатуры, читаются из файла.

13
00:01:47,649 --> 00:01:57,750
Двойное «больше» означает
 добавление в выходной файл.

14
00:01:57,750 --> 00:02:05,439
Число два с «больше» означает перенаправление
стандартного потока ошибок в файл.

15
00:02:05,439 --> 00:02:14,150
По умолчанию stderr также выводит на экран,
и таким образом мы можем отделить этот поток

16
00:02:14,150 --> 00:02:20,060
от stdin и перенаправить в этот файл.

17
00:02:20,060 --> 00:02:24,260
И напоследок -- вот такая волшебная формула.

18
00:02:25,360 --> 00:02:36,260
Это означает, что stdout и stderr
объединены в один поток.

19
00:02:36,260 --> 00:02:45,020
Более подробно эта комбинация символов
 обсуждается в лекции

20
00:02:45,020 --> 00:02:49,780
"Под капотом -- номера потоков".

21
00:02:49,780 --> 00:02:55,269
Вы можете использовать её в сочетании с другим перенаправлением,

22
00:02:55,269 --> 00:02:58,420
например, следующим образом.

23
00:02:58,420 --> 00:03:04,790
Это означает перенаправление в один «файл» как 

24
00:03:04,790 --> 00:03:12,500
стандартного потока вывода, так и
стандартного потока ошибок.

25
00:03:12,500 --> 00:03:18,640
Но учтите -- такие комбинации
не равнозначны.

26
00:03:20,310 --> 00:03:29,629
Во втором случае вы сначала объединяете потоки,
а затем снова разделяете их,

27
00:03:29,629 --> 00:03:39,550
 перенаправляя стандартный вывод в выбранный файл.

28
00:03:39,550 --> 00:03:49,910
В этом случае в файл будет помещен только поток stdout,

29
00:03:49,910 --> 00:03:53,330
на экране будет отображаться stderr.

30
00:03:53,330 --> 00:03:59,779
Порядок операций перенаправления важен!

31
00:03:59,779 --> 00:04:11,640
Возникает вопрос: чего нам не хватает с точки зрения симметрии?

32
00:04:11,640 --> 00:04:16,799
Очевидно -- двойного знака «меньше».

33
00:04:16,799 --> 00:04:24,430
И такое сочетание тоже существует!

34
00:04:24,430 --> 00:04:31,160
Но что может означать это сочетание?

35
00:04:31,160 --> 00:04:35,590
Добавить что-нибудь в стандартный ввод?

36
00:04:35,590 --> 00:04:40,240
Но это какой-то бред.

37
00:04:40,240 --> 00:04:45,220
На самом деле, эта комбинация используется для
 так называемого "встроенного документа" ("Here-document").

38
00:04:46,220 --> 00:04:52,090
После двойного «меньше» ставится какая-то метка

39
00:04:52,090 --> 00:05:01,319
(в нашем случае это END_LABEL), и весь текст
 со следующей строки до END_LABEL отправляется

40
00:05:01,319 --> 00:05:07,120
на стандартный ввод программы,
как если бы он вводился с клавиатуры.

41
00:05:07,120 --> 00:05:15,960
Будьте осторожны, в некоторых старых оболочках
 эта последовательность команд  интерпретирует
 именно то, что вы написали.

42
00:05:15,960 --> 00:05:26,680
И если вы для красоты написали пробел
перед END_LABEL, оболочка будет ждать

43
00:05:26,680 --> 00:05:32,389
 именно такую же строку символов
с начальным пробелом.

44
00:05:32,389 --> 00:05:39,849
И если эта строка не найдётся, перенаправление
из «встроенного документа» будет продолжаться

45
00:05:39,849 --> 00:05:46,379
до конца файла и может быть источником
каких-то непонятных ошибок.

46
00:05:46,379 --> 00:05:51,430
И наконец -- конвейеры (pipelines).

47
00:05:51,430 --> 00:06:03,620
Они создаются с помощью символа
вертикальной черты (pipe) между командами.

48
00:06:03,620 --> 00:06:15,530
Это означает подключение стандартного вывода
первой команды к стандартному вводу

49
00:06:15,530 --> 00:06:22,159
второй команды.

50
00:06:22,159 --> 00:06:31,659
После этого все данные, которые первая команда
отправляет на экран, будут отправлены 

51
00:06:31,659 --> 00:06:40,419
в конвейер, из которого вторая команда
будет считана как с клавиатуры.

52
00:06:40,419 --> 00:06:46,270
Программы, которые создаются в этой
 парадигме перенаправления и конвейерной обработки,
довольно легко разрабатываются и тестируются.

53
00:06:46,270 --> 00:06:54,599
Такие мощные инструменты межпроцессного
взаимодействия помогают нам создавать

54
00:06:54,599 --> 00:06:57,379
довольно сложные комбинации
взаимодействующих программ.

55
00:06:57,379 --> 00:06:58,620
Например вот так.

56
00:07:01,730 --> 00:07:08,349
Первая программа получает данные из файла,

57
00:07:08,349 --> 00:07:18,960
перенаправляя stdin, отправляет
 результат работы в конвейер через stdout

58
00:07:18,960 --> 00:07:33,860
и после долгого пути через цепочку фильтров, в конце
концов, последняя команда отправляет результаты

59
00:07:33,860 --> 00:07:38,939
в stdout, который перенаправляется
в файл результата.

60
00:07:38,939 --> 00:07:51,520
Интересно, что некоторое подобие перенаправления
ввода-вывода поддерживается и в ОС MS,
но с некоторыми неожиданными особенностями.

61
00:07:51,520 --> 00:07:57,200
Подробнее см. в лекции "Под капотом --
работа с текстом в Windows".

