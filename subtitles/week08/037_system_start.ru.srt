1
00:00:05,120 --> 00:00:10,000
Отлично, но как наша система запускается?

2
00:00:11,680 --> 00:00:21,040
Фактически, при включении компьютера запускается специальный код,

3
00:00:23,680 --> 00:00:37,760
встроенный в аппаратную часть -- прошивку.
 Таких прошивок много: классический PC BIOS, UEFI,

4
00:00:37,760 --> 00:00:44,720
Uboot, OpenBoot, Coreboot и т. д.
 Прошивка считывает основной загрузчик с диска:

5
00:00:46,480 --> 00:00:53,120
BIOS из MBR, UEFI из системного раздела EFI и так далее.

6
00:00:54,080 --> 00:01:03,760
Потом запустился вторичный загрузчик. Этот загрузчик
 может быть более или менее сложным и настраиваемым.

7
00:01:03,760 --> 00:01:23,040
Наиболее часто используемые загрузчики Linux в настоящее время -- 
это легкие загрузочные системы, такие как

8
00:01:23,600 --> 00:01:37,040
SYSLINUX для файловой системы FAT, ISOLINUX для образов ISO,

9
00:01:38,320 --> 00:01:52,400
который в основном используется для загрузки установки или живых образов,

10
00:01:52,400 --> 00:01:58,160
и загрузчик общего назначения GRUB.

11
00:01:58,160 --> 00:02:06,480
Обычно GRUB устанавливается во время установки системы,
 включая настройку загрузки других операционных систем,

12
00:02:06,480 --> 00:02:14,320
установленных на вашем компьютере. Но в некоторых случаях MS Windows

13
00:02:14,960 --> 00:02:21,840
на компьютере с двойной загрузкой
 может переустановить загрузчик, не спрашивая вас,

14
00:02:23,360 --> 00:02:31,200
и в этом случае вы можете потерять настройки загрузки.
 Чтобы восстановить их,

15
00:02:31,840 --> 00:02:49,840
необходимо загрузиться с установочного носителя
 в режиме восстановления и запустить программу

16
00:02:53,120 --> 00:02:58,400
`grub2-install` для вашего системного хранилища. Например, таким образом:

17
00:02:58,400 --> 00:03:02,800
# grub2-install /dev/sda

18
00:03:02,800 --> 00:03:17,840
После загрузки ядра запускается специальный процесс, называемый `init`.

19
00:03:33,120 --> 00:03:46,960
В исходном UNIX, как и в BSD, `init` просто запускает сценарий

20
00:03:51,840 --> 00:03:59,840
`/etc/rc`, который полностью определяет дальнейшее поведение системы.

21
00:04:00,960 --> 00:04:08,400
Для систем SYSV реализован другой механизм `init`.

22
00:04:08,400 --> 00:04:17,280
В таких системах вы можете вызвать программу `init`
 в любое время, установив уровень запуска в качестве параметра. 

23
00:04:18,800 --> 00:04:34,700
Уровни выполнения, определенные в конфигурации `init`,

24
00:04:34,700 --> 00:04:38,720
находятся в файле '/etc/inittab'.

25
00:04:38,720 --> 00:04:39,760
Каждая строка в файле` inittab`

26
00:04:39,760 --> 00:04:50,400
состоит из четырех полей, разделенных двоеточиями,

27
00:04:50,400 --> 00:04:57,200
и описывает:
* какие процессы запускать, отслеживать

28
00:04:57,200 --> 00:05:05,600
и перезапускать, если они завершаются
* какие действия предпринимать,

29
00:05:06,720 --> 00:05:13,360
когда система переходит на новый уровень запуска
* поля Inittab

30
00:05:14,160 --> 00:05:16,640
уровня запуска по умолчанию:

31
00:05:19,440 --> 00:05:26,880
* id (идентификационный код) -- состоит

32
00:05:28,000 --> 00:05:34,400
из последовательности от одного до четырех символов,

33
00:05:35,120 --> 00:05:42,720
определяющих ее функцию.
* runlevels -- перечисляет

34
00:05:42,720 --> 00:05:52,560
уровни запуска, к которым применяется эта запись.
* Коды действий в этом поле сообщают init,

35
00:05:53,440 --> 00:05:59,440
как обрабатывать процесс. Возможные значения включают: initdefault,

36
00:06:01,040 --> 00:06:07,600
sysinit, boot, bootwait, wait и respawn.
* процесс -- определяет команду

37
00:06:08,880 --> 00:06:11,120
или сценарий для выполнения.

38
00:06:13,440 --> 00:06:15,280
Строка initdefault определяет уровень запуска по умолчанию.

39
00:06:17,200 --> 00:06:27,520
В разных системах определены разные иерархии
 уровней инициализации, но некоторые из них

40
00:06:27,520 --> 00:06:34,000
имеют одно и то же значение:
* Уровень выполнения 0 -- остановка.

41
00:06:34,000 --> 00:06:44,560
* Уровень запуска 6 -- перезагрузка.
* Уровень выполнения 1 -- однопользовательский.

42
00:06:44,560 --> 00:06:59,040
* и уровни выполнения от 2 до 5 чаще всего являются
 уровнями выполнения для нескольких пользователей.

43
00:06:59,040 --> 00:07:10,000
Чаще всего исполняемые сценарии в `inittab`
 представляют собой просто некоторые сценарии `rc`,

44
00:07:10,000 --> 00:07:15,840
которые размещаются в соответствующих каталогах

45
00:07:19,120 --> 00:07:43,840
`/etc/rc<runlevel>.d/` и сначала запускаются сценарии остановки,

46
00:07:47,360 --> 00:08:02,960
начиная с большого K (kill) с параметром 'stop', а затем --
 сценарии, которые начинаются с большой буквы S

47
00:08:06,000 --> 00:08:08,432
с параметром 'start':

48
00:08:09,440 --> 00:08:16,640
И, как мы видим, этот сценарий

49
00:08:22,480 --> 00:08:30,800
представляет собой просто символические ссылки на сценарии из `/etc/init.d/`,

50
00:08:32,560 --> 00:08:39,840
кроме того, сценарии Kill и сценарии Start
 могут быть связаны с одним и тем же файлом.

51
00:08:40,800 --> 00:08:46,880
Если мы посмотрим на них, то увидим -- есть просто скрипты,
 которые что-то делают в соответствии с параметром

52
00:08:46,880 --> 00:08:54,840
`start` или` stop`:
$ less /etc/init.d/network

53
00:09:08,720 --> 00:09:13,600
Start, stop.

54
00:09:13,600 --> 00:09:21,600
И если вы хотите реализовать свой собственный сценарий службы,
 вам просто нужно поддерживать для этого параметры start и stop.

55
00:09:21,600 --> 00:09:29,760
Чтобы настроить свою собственную политику
 для остановки и запуска служб

56
00:09:30,640 --> 00:09:37,680
на любом уровне, вам просто нужно слинковать
 нужные вам сценарии из `/etc/init.d/`

57
00:09:38,400 --> 00:09:44,560
с соответствующими каталогами уровня выполнения.
 Порядок, в котором запускаются сценарии,

58
00:09:44,560 --> 00:09:49,840
определяется числами в начале имен файлов.

59
00:09:51,120 --> 00:10:07,920
Некоторые команды, которые могут помочь в этой работе:
* `service` -- запускать или останавливать служебный сценарий System V

60
00:10:07,920 --> 00:10:18,400
* `setup` и `chkconfig` -- обновлять и запрашивать информацию
 об уровне запуска для системных служб.

61
00:10:20,080 --> 00:10:29,440
Но наиболее часто используемые дистрибутивы Linux
 используют теперь `systemd` вместо таких систем.

62
00:10:30,160 --> 00:10:38,640
Основное преимущество этой системы -- более быстрый
 параллельный запуск сервисов при старте системы,

63
00:10:38,640 --> 00:10:48,000
а также унификация сервисов и работа с устройствами.
 Эти утилиты и скрипты всё еще

64
00:10:49,280 --> 00:10:59,840
присутствуют для совместимости,
 но теперь основным инструментом

65
00:11:03,680 --> 00:11:04,434
является `systemctl`.

66
00:11:06,880 --> 00:11:13,840
Мы можем просмотреть список системных служб,
 запускать, останавливать и получать их статус,

67
00:11:14,720 --> 00:11:20,560
включать и отключать их автоматический запуск во время загрузки.

68
00:11:21,120 --> 00:11:28,720
Чтобы узнать сообщения журнала о запуске загрузки и работе системы,

69
00:11:29,520 --> 00:11:34,520
мы можем просмотреть файлы системного журнала. Например:

70
00:11:42,000 --> 00:12:04,160
*  `/var/log/messages` -- в RH-подобных дистрибутивах Linux
* или `/var/log/syslog` -- в Debian и Ubuntu

71
00:12:06,000 --> 00:12:20,160
В современных дистрибутивах Linux на основе `systemd`

72
00:12:20,160 --> 00:12:28,560
мы имеем` journalctl`

73
00:12:28,560 --> 00:12:36,400
команду для работы с журнальной системой `systemd`.

