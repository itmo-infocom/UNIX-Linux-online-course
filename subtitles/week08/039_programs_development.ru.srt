1
00:00:05,400 --> 00:00:09,820
И теперь мы готовы заняться своего рода проектом по разработке программы.

2
00:00:09,820 --> 00:00:15,299
У нас уже есть приложение "hello world".

3
00:00:15,299 --> 00:00:25,710
А теперь попробуем реализовать следующую
 традиционную для начинающих разработчиков программу --

4
00:00:25,710 --> 00:00:28,320
калькулятор.

5
00:00:28,320 --> 00:00:37,320
В результате мы получим сетевое клиент-серверное приложение
 с локализованным на русский язык

6
00:00:37,320 --> 00:00:41,170
графическим пользовательским интерфейсом.

7
00:00:41,170 --> 00:00:49,980
Код этого проекта можно найти на github.

8
00:00:49,980 --> 00:01:05,479
Github и, например, GitLab поддерживают хостинг для разработки программного обеспечения и контроля версий с помощью Git.

9
00:01:05,479 --> 00:01:18,619
Version control (контроль версий), также известный как revision control,
 source control, или source code management --

10
00:01:18,619 --> 00:01:24,939
это класс систем для управления изменениями
 компьютерных программ, документов,

11
00:01:24,939 --> 00:01:38,100
больших веб-сайтов или других наборов информации.

12
00:01:38,100 --> 00:01:44,740
Контроль версий -- это компонент управления
 конфигурацией программного обеспечения.

13
00:01:44,740 --> 00:01:51,380
VCS первого поколения предназначались
 для отслеживания изменений отдельных файлов,

14
00:01:51,380 --> 00:02:05,270
а извлеченные файлы могли редактироваться локально
 только одним пользователем.

15
00:02:05,270 --> 00:02:12,270
Они были построены на предположении,
 что все пользователи будут входить в один и тот же

16
00:02:12,270 --> 00:02:24,700
общий хост Unix со своими учетными записями.

17
00:02:24,700 --> 00:02:38,599
Во втором поколении VCS появилась поддержка сети,
 которая привела к централизованным репозиториям,

18
00:02:38,599 --> 00:02:46,180
содержащим «официальные» версии проектов.

19
00:02:46,180 --> 00:02:53,140
Это был хороший прогресс, поскольку он позволял 
нескольким пользователям скачивать код

20
00:02:53,140 --> 00:03:09,640
и работать с ним одновременно, но все равно
 всё вертелось вокруг единой точки отказа --

21
00:03:09,640 --> 00:03:11,590
центрального репозитория.

22
00:03:11,590 --> 00:03:19,640
Кроме того, для совершения коммитов требовался доступ к сети.

23
00:03:19,640 --> 00:03:25,050
Третье поколение -- распределенная VCS.

24
00:03:25,050 --> 00:03:36,996
В распределенной VCS все копии репозитория равноправны --

25
00:03:36,996 --> 00:03:43,439
как правило, нет центральной копии репозитория.

26
00:03:43,439 --> 00:03:54,939
Это открывает путь для коммитов, ветвей и слияний,
 которые будут созданы локально без доступа к сети

27
00:03:54,939 --> 00:03:59,330
и при необходимости переданы в другие репозитории.

28
00:03:59,330 --> 00:04:15,500
Существует множество систем VCS, разработанных и используемых
 в UNIX-подобных системах: SCCS, RCS, CVS, SVN,

29
00:04:15,500 --> 00:04:22,510
Mercurial, Bazzar и т.д., и в настоящее время
 наиболее популярным из них является Git.

30
00:04:22,510 --> 00:04:23,010
Git -- это распределенная система контроля версий
 для отслеживания изменений в исходном коде

31
00:04:23,010 --> 00:04:31,300
во время разработки программного обеспечения.

32
00:04:31,300 --> 00:04:45,770
Он был создан Линусом Торвальдсом в 2005 году для разработки ядра Linux.

33
00:04:45,770 --> 00:04:55,050
Базовым инструментом для работы с репозиториями Git

34
00:04:55,050 --> 00:04:56,050
является утилита `git`.

35
00:05:02,710 --> 00:05:04,400
Сначала нам нужно «клонировать» наш репозиторий:

36
00:05:04,400 --> 00:05:27,780
$ git clone https://github.com/itmo-infocom/calc_examples
$ ls calc_examples

37
00:05:27,780 --> 00:05:36,150
Отлично -- теперь у нас есть собственная локальная копия.

38
00:05:36,150 --> 00:05:38,339
Заходим внутрь:

39
00:05:38,339 --> 00:05:42,069
$ cd calc_examples/

40
00:05:42,069 --> 00:05:51,129
Теперь давайте посмотрим на теги, которые
 указывают на разные этапы разработки:

41
00:05:51,129 --> 00:05:52,289
$ git tag

42
00:05:52,289 --> 00:05:56,640
Example_1
...
Example_9

43
00:05:56,640 --> 00:06:01,319
А теперь перейдем к начальному этапу:

44
00:06:01,319 --> 00:06:12,500
$ git checkout Example_1
$ ls

45
00:06:12,509 --> 00:06:29,039
Как мы можем видеть, большинство файлов исчезло,
 и теперь у нас есть только README и Makefile.

46
00:06:29,039 --> 00:06:33,480
Давайте взглянем на README:

47
00:06:33,480 --> 00:06:42,660
$ cat README.md

48
00:06:42,670 --> 00:06:45,630
и Makefile:

49
00:06:45,630 --> 00:06:52,000
$ cat Makefile

50
00:06:52,009 --> 00:07:09,800
Makefile -- это файл, содержащий набор директив, используемых
 утилитой `make` -- инструментом автоматизации сборки

51
00:07:09,800 --> 00:07:14,820
для генерации некоей цели (target/goal).

52
00:07:14,820 --> 00:07:21,820
Make -- самый старый и наиболее широко используемый
 инструмент отслеживания зависимостей

53
00:07:21,820 --> 00:07:27,030
для создания программных проектов.

54
00:07:27,030 --> 00:07:37,449
Он используется при разработке крупных проектов,
 таких как ядро ​​Linux, с десятками миллионов

55
00:07:37,449 --> 00:07:39,390
строк исходного кода.

56
00:07:39,390 --> 00:07:49,330
Обычно использовать `make` довольно просто:
 вы просто запускаете `make` без аргументов:

57
00:07:52,509 --> 00:08:02,500
в этом случае утилита пытается найти `makefile`,

58
00:08:02,500 --> 00:08:10,600
который начинается со строчной буквы, а затем с заглавной.

59
00:08:10,600 --> 00:08:19,090
Обычно Makefile с заглавной буквой помещается в проект,
 версия в нижнем регистре часто используется

60
00:08:19,090 --> 00:08:27,270
для некоторых локальных изменений
 во время тестирования и настройки Makefile

61
00:08:27,270 --> 00:08:29,690
исходного проекта.

62
00:08:29,690 --> 00:08:37,130
Формат `makefile` довольно прост --
 это просто набор правил для сборки проектов:

63
00:08:37,130 --> 00:08:38,130
$ cat Makefile

64
00:08:38,130 --> 00:08:46,850
В первой позиции мы видим «цель»,

65
00:08:46,850 --> 00:08:56,090
после двоеточия могут быть размещены зависимости,
 которые являются просто другими целями.

66
00:08:56,090 --> 00:09:06,340
Строки, следующие за описанием целей и зависимостей,
 которые начинаются с символа табуляции,

67
00:09:06,340 --> 00:09:15,010
есть команды, которые должны быть выполнены для завершения этой цели.

68
00:09:15,010 --> 00:09:24,870
Если зависимости являются файлами,
 make проверяет время модификации этих файлов

69
00:09:24,870 --> 00:09:34,270
и рекурсивно перестраивает эти целевые объекты зависимостей.

70
00:09:34,270 --> 00:09:43,000
Текущий Makefile включает лишь несколько целей
 для работы с репозиторием Git.

71
00:09:43,000 --> 00:09:46,560
Первый запустится по умолчанию.

72
00:09:46,560 --> 00:09:55,980
Если мы хотим запустить другую цель, мы должны
передать ее как параметр при запуске утилиты `make`.

