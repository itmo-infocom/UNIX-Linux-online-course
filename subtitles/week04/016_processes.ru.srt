1
00:00:06,480 --> 00:00:10,080
Мы обсудили пользователей,

2
00:00:11,280 --> 00:00:20,720
а теперь уместно поговорить об еще одном из трех китов, на которых покоятся

3
00:00:21,440 --> 00:00:32,160
UNIX-подобные системы, -- процессах. Мы можем получить
 информацию о процессах, запустив команду

4
00:00:33,600 --> 00:00:46,800
`ps` (статус процесса). В этом случае мы снова видим
 два мира, две системы -- SYSV и BSD:

5
00:00:50,000 --> 00:00:52,640
А как насчет GNU?

6
00:00:52,640 --> 00:00:57,440
$ man ps

7
00:00:57,440 --> 00:01:11,840
Как мы видим, GNU `ps` поддерживает оба набора параметров
 с некоторыми специфичными для GNU длинными параметрами.

8
00:01:12,720 --> 00:01:13,520
По умолчанию

9
00:01:19,680 --> 00:01:31,200
`ps` без параметров показывает только процессы, запущенные мной
 и подключенные к моей текущей строке терминала.

10
00:01:32,640 --> 00:01:40,840
Чтобы получить статус для всех процессов, мы должны использовать:

11
00:01:44,880 --> 00:02:04,000
* `ps -ef` для SYSV и` ps ax` («тире» можно опустить) для BSD.

12
00:02:04,960 --> 00:02:10,320
И мы можем получить больше информации о процессах, используя

13
00:02:14,960 --> 00:02:18,200
опцию "long":

14
00:02:21,680 --> 00:02:30,560
* ps -l для SYSV
* или просто «l» для BSD

15
00:02:34,320 --> 00:02:40,246
Какую информацию о процессах мы можем видеть?

16
00:02:40,246 --> 00:02:43,568
$ ps ax | less

17
00:02:43,568 --> 00:02:55,040
* UID -- эффективный идентификатор пользователя.
 У процесса может быть иной идентификатор, чем у пользователя,

18
00:02:55,040 --> 00:03:04,800
запускающего приложение, потому что, как мы увидим позже,
 в UNIX-подобных системах существует механизм для изменения

19
00:03:05,360 --> 00:03:14,080
идентификатора на время выполнения программы.
* PID -- число, представляющее уникальный идентификатор процесса.

20
00:03:14,080 --> 00:03:24,080
* PPID -- идентификатор родительского процесса. Собственно, у нас есть

21
00:03:24,080 --> 00:03:32,800
иерархическая система процессов, и у каждого процесса
 есть свой родитель. Мы можем увидеть эту иерархию,

22
00:03:34,640 --> 00:03:46,473
например, с помощью такого набора параметров:

23
00:03:46,473 --> 00:03:50,480
$ ps axjf | less

24
00:03:50,480 --> 00:03:53,504
или просто при помощи команды:

25
00:03:53,504 --> 00:04:00,340
$ pstree

26
00:04:00,340 --> 00:04:14,320
* PRI -- приоритет процесса. Чем больше число,
 тем ниже приоритет. Но, как мы обсудим позже,

27
00:04:15,280 --> 00:04:23,040
мы не можем изменить приоритет,
 потому что это значение динамически изменяется

28
00:04:23,040 --> 00:04:28,960
планировщиком процессов. И мы можем
 отправлять планировщику только рекомендации

29
00:04:30,480 --> 00:04:44,320
 с помощью параметра `nice` (NI): 
* NI -- можно задать с помощью команд` nice` и `renice`.

30
00:04:44,320 --> 00:04:55,840
Более подробную информацию о приоритетах и ​​тонкостях
 можно найти в лекции «Под капотом -- планировщик процессов».

31
00:04:55,840 --> 00:05:03,520
* TTY -- управляющий tty (терминал).
* и CMD -- команда.

32
00:05:06,400 --> 00:05:13,600
А также очень полезная (особенно если система тормозит) команда

33
00:05:16,880 --> 00:05:23,040
`top`, которая динамически отображает информацию о процессах,

34
00:05:23,040 --> 00:05:29,920
отсортированную в соответствии с используемыми
 системными ресурсами -- памятью и процессорным временем.

35
00:05:32,480 --> 00:05:41,000
`nice` -- запустить программу

36
00:05:42,240 --> 00:05:47,994
с измененным приоритетом планирования:

37
00:05:47,994 --> 00:05:49,440
$ man nice

38
00:05:49,440 --> 00:06:01,360
Значение `nice` -- целое число. Наименьшее число
 означает наивысший приоритет. Диапазон nice

39
00:06:01,360 --> 00:06:10,560
может быть разным в разных системах, и вам имеет смысл
 глянуть на «man nice» в вашей системе.

40
00:06:11,280 --> 00:06:26,640
В случае Linux значение nice -- от -20 до 19.
 Только суперпользователь может увеличить

41
00:06:26,640 --> 00:06:33,840
приоритет, обычный пользователь может лишь уменьшить значение, установленное по умолчанию, что можно увидеть,

42
00:06:37,200 --> 00:06:47,840
вызвав программу "nice" без аргументов.

43
00:06:48,880 --> 00:06:54,000
Например:

44
00:06:54,000 --> 00:07:19,200
`nice -n 19 command args ...`

45
00:07:19,200 --> 00:07:29,280
означает выполнение команды с самым низким приоритетом.
 Это может быть полезно для снижения

46
00:07:29,280 --> 00:07:36,560
активности неинтерактивных приложений, например, таких как

47
00:07:36,560 --> 00:07:43,840
процесс резервного копирования, что может замедлить интерактивный отклик системы.

48
00:07:47,760 --> 00:08:00,240
renice -- изменяет приоритет запущенных процессов по PID.
 В этом случае вы можете не использовать

49
00:08:02,880 --> 00:08:06,000
опцию «-n», а только значение 'nice'.

50
00:08:07,280 --> 00:08:12,840
Например:

51
00:08:12,840 --> 00:08:23,040
`renice 19 PID ...`

52
00:08:23,040 --> 00:08:26,720
вот таким образом.

53
00:08:26,720 --> 00:08:32,400
На уровне оболочки мы можем использовать механизм `jobs`.

54
00:08:32,400 --> 00:08:41,200
Самый простой способ начать новое фоновое задание --
 использовать символ & (амперсанд).

55
00:08:41,200 --> 00:08:41,840
gedit & xterm -e top

56
00:08:54,400 --> 00:09:07,840
После выполнения команды мы можем отключиться
 от строки терминала и приостановить ее,

57
00:09:10,880 --> 00:09:34,480
нажав '^Z'. Как мы видим, `top` в` xterm` теперь останавливается
 просто потому, что приложение `xterm` остановлено.

58
00:09:35,120 --> 00:09:42,320
Мы можем видеть фоновые и приостановленные задания,
 используя команду `jobs`:

59
00:09:42,328 --> 00:09:47,760
$ jobs

60
00:09:47,760 --> 00:09:55,280
В первой позиции списка заданий мы видим номер задания.

61
00:09:55,840 --> 00:10:03,840
Мы можем использовать этот номер задания со знаком «процента» перед ним.

62
00:10:04,960 --> 00:10:14,640
Приостановленную задачу мы можем переключить
 в фоновый режим выполнения.

63
00:10:15,600 --> 00:10:19,400
По умолчанию -- текущее задание.

64
00:10:20,640 --> 00:10:22,880
Как видим, `top`

65
00:10:27,120 --> 00:10:32,520
снова запущен.

66
00:10:32,520 --> 00:10:38,880
И мы можем повторно подключить фоновое задание
 к строке терминала, переведя его

67
00:10:38,880 --> 00:10:40,581
на основной режим.

68
00:10:40,978 --> 00:10:41,920
После этого мы можем

69
00:10:41,920 --> 00:10:46,720
прервать работу задания, нажав '^C'.

70
00:10:46,720 --> 00:10:54,240
Вот `xterm` убит.

71
00:10:54,240 --> 00:10:56,320
Другой способ завершить

72
00:10:57,280 --> 00:11:02,384
процесс -- использовать команду kill.

73
00:11:09,360 --> 00:11:13,840
Также вы можете убить

74
00:11:17,440 --> 00:11:21,553
процесс по номеру PID:

75
00:11:22,207 --> 00:11:23,520
Но в некоторых случаях

76
00:11:25,040 --> 00:11:35,840
kill не работает -- например, если процесс заморожен.
 Но даже в этом случае

77
00:11:35,840 --> 00:11:45,840
мы можем убить процесс только потому,
 что `kill` на самом деле посылает сигнал процессу,

78
00:11:45,840 --> 00:11:56,960
и нам просто нужно выбрать другой сигнал.

79
00:12:01,200 --> 00:12:02,160
Это список сигналов:

80
00:12:02,160 --> 00:12:03,433
kill -l

81
00:12:03,433 --> 00:12:08,240
15) SIGTERM -- общий сигнал, используемый для
завершения программы (по умолчанию kill)

82
00:12:09,520 --> 00:12:19,440
2) SIGINT -- «прерывание программы» (клавиша INTR -- обычно Ctrl-C)

83
00:12:21,920 --> 00:12:35,040
9) SIGKILL -- немедленное завершение программы
(не может быть заблокирован, обработан или проигнорирован)

84
00:12:36,640 --> 00:12:49,360
1) SIGHUP -- терминальная линия отключена (часто используется
 для перечитывания конфигурации процессов-демонов,

85
00:12:49,360 --> 00:13:08,000
только потому, что они не подключены к TTY)
3) SIGQUIT -- процесс дампа ядра (клавиша QUIT, как мы помним -- обычно Ctrl-\)

86
00:13:09,440 --> 00:13:18,480
Когда вы выполняете задание Unix в фоновом режиме
 (с помощью команды & или `bg`)

87
00:13:19,040 --> 00:13:30,080
и выходите из сеанса, ваш процесс будет убит.
 Этого можно избежать,

88
00:13:31,440 --> 00:13:34,640
используя команду `nohup`:

89
00:13:34,640 --> 00:13:41,600
nohup -- запуск команды, невосприимчивой к разрыву
 терминальной линии с выводом в nohup.out.

90
00:13:41,600 --> 00:13:48,560
Другой очень полезной программой является «screen» --

91
00:13:48,560 --> 00:13:57,040
это диспетчер экранов с эмуляцией терминала
VT100 / ANSI, который поддерживает несколько вариантов.
Поддержка сеансов экрана с автономным исполнением.

92
00:13:59,360 --> 00:14:07,600
Фактически, вы можете запускать команды, исполняемые в течение длительного времени,  в сеансах с несколькими экранами

93
00:14:07,600 --> 00:14:17,280
и после отключения от этой линии терминала
 руками или после разрыва соединения.

94
00:14:17,280 --> 00:14:25,840
Затем вы можете подключиться к этому screen,
 и вы увидите, что все процессы по-прежнему работают.

95
00:14:28,720 --> 00:14:38,400
И еще одна возможность автономного выполнения команд --
это более позднее выполнение и запланированные команды.

96
00:14:38,400 --> 00:14:47,200
at, batch, ATQ, atrm -- для помещения в очередь, её просмотра

97
00:14:48,480 --> 00:14:53,040
и удаления задания для отложенного выполнения

98
00:14:53,040 --> 00:15:01,920
И для управления планировщиком запуска по расписанию `cron` мы имеем

99
00:15:05,120 --> 00:15:06,680
команду` crontab`.

100
00:15:07,920 --> 00:15:16,320
Она поддерживает системные crontab-файлы
или таблицы расписания запуска процессов

101
00:15:16,320 --> 00:15:21,345
для отдельных пользователей.

