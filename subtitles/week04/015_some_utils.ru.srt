1
00:00:07,109 --> 00:00:12,360
OK, мы только что вошли в систему. Но теперь мы хотим

2
00:00:12,360 --> 00:00:22,200
попытаться определить, в какой части UNIX-вселенной мы находимся.

3
00:00:22,200 --> 00:00:37,000
`uname` выводит системную информацию, в простейшем случае --

4
00:00:37,000 --> 00:00:52,690
просто имя ядра. С флагом «all» мы получим больше информации.
 А для чего можно было бы использовать

5
00:00:52,690 --> 00:01:04,640
такую ​​информацию? Из простого любопытства?
 Ответ прост -- её можно использовать для

6
00:01:04,640 --> 00:01:12,450
создания переносимых приложений или каких-то
 административных скриптов для различных типов

7
00:01:12,450 --> 00:01:19,700
UNIX-подобных систем. Вы можете использовать её
 в сценариях установки или конфигурации оболочки

8
00:01:19,700 --> 00:01:27,470
для выбора различных бинарных файлов и системных утилит
 в соответствии с архитектурой вашего компьютера

9
00:01:27,470 --> 00:01:30,310
и ОС.

10
00:01:30,310 --> 00:01:45,200
Это неплохо работает для старых добрых систем UNIX,
 которые очень зависят от производителя. Но в системах

11
00:01:45,200 --> 00:01:55,350
Linux `uname` отображает только имя ядра Linux, возможно, с версией ядра.

12
00:01:55,350 --> 00:02:05,689
И, как мы знаем, имеется много разных дистрибутивов Linux,
 которые могут сильно отличаться

13
00:02:05,689 --> 00:02:13,820
друг от друга. И как нам адаптироваться к этому разнообразию?

14
00:02:13,820 --> 00:02:25,410
Одна из возможностей -- команда `lsb_release`:

15
00:02:25,410 --> 00:02:37,430
` lsb_release` предоставляет определенную LSB (Linux Standard Base)
 и информацию, относящуюся к конкретному дистрибутиву.

16
00:02:37,430 --> 00:02:46,120
Linux Standard Base (LSB) -- это совместный проект
 нескольких дистрибутивов Linux в рамках организационной

17
00:02:46,120 --> 00:02:53,960
структуры Linux Foundation по стандартизации
 структуры программной системы, включая

18
00:02:53,960 --> 00:03:05,069
Filesystem Hierarchy Standard (стандарт иерархии файловой системы).
 LSB основан на спецификации POSIX, Single

19
00:03:05,069 --> 00:03:12,520
UNIX Specification и нескольких
 других открытых стандартах, но расширяет их

20
00:03:12,520 --> 00:03:13,639
в некоторых областях.

21
00:03:13,639 --> 00:03:21,230
Хорошо. Получаем информацию о том, «где». Давайте

22
00:03:21,230 --> 00:03:27,860
попробуем разобраться, «когда».

23
00:03:27,860 --> 00:03:42,010
`date` -- вывести системную дату и время. Сколько времени?
 Текущее время нашего часового пояса.

24
00:03:42,010 --> 00:03:50,689
Мы можем проверить время в другом часовом поясе,
 например, по Гринвичу (GMT):

25
00:03:50,689 --> 00:03:53,930
$ TZ = GMT date

26
00:03:53,930 --> 00:04:04,409
Мы также можем установить текущее компьютерное время:

27
00:04:04,409 --> 00:04:09,680
$ man date

28
00:04:09,680 --> 00:04:18,019
Месяц, день, часы, минуты, может быть годы и секунды.

29
00:04:19,019 --> 00:04:32,539
Также мы можем выбрать другой формат вывода
 для времени и даты с помощью опции «+»:

30
00:04:32,539 --> 00:04:39,199
date +% F_% T_% Z

31
00:04:39,199 --> 00:04:44,460
и использовать эту команду для преобразования из различных

32
00:04:44,460 --> 00:04:59,589
представлений времени с помощью опции «--date». Вы можете найти более подробную информацию

33
00:04:59,589 --> 00:05:02,729
в руководстве man.

34
00:05:02,729 --> 00:05:07,979
И, конечно же, мы можем увидеть календарь:

35
00:05:07,979 --> 00:05:09,949
$ cal
$ man cal

36
00:05:12,560 --> 00:05:23,619
Например, календарь на первый год эпохи UNIX:

37
00:05:23,619 --> 00:05:28,840
$ cal 1970

38
00:05:28,849 --> 00:05:43,009
Хорошо -- «что», «когда», но как насчет «кто»?

39
00:05:43,009 --> 00:05:55,009
Как мы уже говорили ранее, мы знаем, что пользователи и группы --
 это всего лишь некие магические числа.

40
00:05:55,009 --> 00:06:02,419
Давайте посмотрим на информацию о пользователе -- команду `id`.

41
00:06:02,419 --> 00:06:13,399
`id` -- вывести реальные и эффективные
 идентификаторы пользователей и групп.

42
00:06:13,399 --> 00:06:21,370
Но также у нас есть еще одна команда -- `logname`:

43
00:06:21,370 --> 00:06:26,439
она печатает логин пользователя.

44
00:06:26,439 --> 00:06:31,020
Для каких нужд мы можем использовать эту команду,

45
00:06:31,020 --> 00:06:47,080
если у нас уже есть команда` id`?
 Во-первых: насколько мы помним, у нас разные

46
00:06:47,080 --> 00:06:59,550
пользователи, причем разные типы пользователей.
 Итак, посмотрим... Это обычная пользовательская сессия.

47
00:06:59,550 --> 00:07:17,160
Имя пользователя -- «user». И мы можем видеть
 одно и то же имя пользователя в командах id и logname.

48
00:07:17,169 --> 00:07:24,249
Это сеанс пользователя root.

49
00:07:24,249 --> 00:07:32,860
Он, как мы помним, является суперпользователем.
 И мы видим совершенно другой результат команды `id`

50
00:07:32,860 --> 00:07:38,140
$ id

51
00:07:38,140 --> 00:07:43,770
Мы видим информацию о суперпользователе root.

52
00:07:43,770 --> 00:07:58,480
Но `logname` покажет одинаковый результат в обоих случаях.

53
00:07:58,480 --> 00:08:08,229
Просто потому что мы вошли в систему пользователем
 с именем «user» в обоих сеансах, а затем переключились

54
00:08:08,229 --> 00:08:21,460
на суперпользователя с помощью команды `sudo` или `su`.
 В некоторых случаях это может быть важно,

55
00:08:21,460 --> 00:08:26,349
и вы можете использовать эту команду
 для определения реального идентификатора пользователя.

56
00:08:27,349 --> 00:08:36,580
Как мы помним, UNIX-подобная система -- 
это многопользовательская среда, и у нас есть много утилит

57
00:08:36,580 --> 00:08:40,000
для работы с такой системой.

58
00:08:40,000 --> 00:08:59,009
`who` -- показывает, кто вошел в систему.

59
00:09:01,259 --> 00:09:08,480
И` finger` -- программа поиска информации о пользователе --
более информативная команда, включая

60
00:09:08,480 --> 00:09:09,480
время простоя пользователя .

61
00:09:10,480 --> 00:09:20,110
На этом этапе можно понять, что конкретный пользователь
 все еще сидит за своим рабочим местом

62
00:09:20,110 --> 00:09:31,639
или ушел кофе попить. Более того, мы можем видеть
 статус пользователя на других компьютерах.

63
00:09:31,639 --> 00:09:38,410
Но как клиент-серверное приложение ему требуется
 серверная часть на запрошенном вами компьютере

64
00:09:38,410 --> 00:09:41,450
и возможность подключения к нему.

65
00:09:41,450 --> 00:09:52,899
Если вы найдете нужного пользователя в списке
 пользователей компьютера, вы можете отправить ему сообщение

66
00:09:52,899 --> 00:10:01,359
вручную или из программы, используя команду `write`:

67
00:10:01,359 --> 00:10:06,430
$ man write

68
00:10:06,430 --> 00:10:10,980
Просто введите что-нибудь и завершите свое сообщение

69
00:10:10,980 --> 00:10:22,570
EOF (^D, как мы помним). В этой команде мы можем
 выбрать строку терминала для записи.

70
00:10:24,520 --> 00:10:37,459
А насчет терминальных линий -- мы можем получить
 нашу текущую терминальную строку

71
00:10:37,459 --> 00:10:40,399
с помощью команды tty.

72
00:10:40,399 --> 00:10:41,620
$ tty

73
00:10:41,620 --> 00:10:49,480
Он просто печатает имя файла терминала, подключенного к стандартному вводу.

74
00:10:49,480 --> 00:11:06,449
У нас также есть команда `stty` для печати
 и изменения настроек строки терминала:

75
00:11:06,449 --> 00:11:08,259
$ stty

76
00:11:08,259 --> 00:11:17,589
с параметром` -a | --all` мы можем получить все

77
00:11:17,589 --> 00:11:24,279
текущие настройки драйвера в этой строке терминала:

78
00:11:24,279 --> 00:11:28,019
$ stty -a

79
00:11:28,019 --> 00:11:33,899
А затем мы можем изменить эти настройки с помощью

80
00:11:33,899 --> 00:11:40,829
этой команды. Например, ранее обсуждавшаяся
 настройка клавиши Delete для прерывания

81
00:11:40,829 --> 00:11:46,250
программы в некоторых старых системах UNIX.

82
00:11:46,250 --> 00:11:53,170
$ man stty

83
00:11:53,170 --> 00:12:06,320
Еще одно замечание о старых системах UNIX: 
в `stty` в таких системах может не быть опции

84
00:12:06,320 --> 00:12:20,249
'-F' (файл) для выбора указанного УСТРОЙСТВА вместо stdin.
 Но у нас все еще есть возможность

85
00:12:20,249 --> 00:12:39,129
выбрать устройство -- просто перенаправив stdin на другое устройство TTY:

86
00:12:39,129 --> 00:12:44,199
stty </ dev / tty0

87
00:12:44,199 --> 00:12:51,019
Это выглядит несколько странно, но таково было

88
00:12:51,019 --> 00:12:54,050
решение разработчика старого доброго UNIX.

