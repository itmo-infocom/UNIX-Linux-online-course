1
00:00:06,069 --> 00:00:13,570
И теперь, когда наше разбиение на разделы завершено, пора посмотреть,
 как мы можем использовать наше дисковое пространство.

2
00:00:13,570 --> 00:00:27,500
Как упоминалось ранее, UNIX-подобные системы
могут обрабатывать диски или их разделы как файлы.

3
00:00:27,500 --> 00:00:39,350
А некоторые базы данных, например, могут использовать
 "сырые" разделы диска для хранения данных

4
00:00:39,350 --> 00:00:40,430
с более высокой производительностью.

5
00:00:40,430 --> 00:00:48,149
Но большую часть времени дисковое пространство
 используется в файловых системах.

6
00:00:48,149 --> 00:00:56,899
UNIX-подобные системы и особенно Linux поддерживают
 множество различных файловых систем.

7
00:00:56,899 --> 00:01:07,960
Все детали их реализации сводятся к общему знаменателю

8
00:01:07,960 --> 00:01:12,810
абстракцией виртуальной файловой системы (VFS).

9
00:01:12,810 --> 00:01:22,520
Один из первых механизмов виртуальной файловой системы
 в Unix-подобных системах был представлен

10
00:01:22,520 --> 00:01:25,970
Sun Microsystems в 1985 году.

11
00:01:25,970 --> 00:01:43,060
Он позволил системным вызовам Unix прозрачно обращаться
 к локальным файловым системам UFS и сетевым файловым системам NFS.

12
00:01:43,070 --> 00:01:54,630
По этой причине поставщики Unix,
 которые лицензировали код NFS у Sun,

13
00:01:54,630 --> 00:01:58,810
часто копировали дизайн Sun VFS.

14
00:01:58,810 --> 00:02:10,179
После создания файловой системы мы можем смонтировать ее
 в едином дереве каталогов, перемещаться по иерархии,

15
00:02:10,179 --> 00:02:21,190
читать, писать, работать с правами пользователей
 в соответствии с ограничениями,

16
00:02:21,190 --> 00:02:26,610
налагаемыми внутренней организацией файловой системы.

17
00:02:26,610 --> 00:02:41,100
Стандартный инструмент для создания новой файловой системы -- `mkfs`:

18
00:02:45,350 --> 00:02:56,140
мы можем выбрать тип файловой системы

19
00:02:56,140 --> 00:02:58,510
 и какие-то параметры для создания.

20
00:02:58,510 --> 00:03:07,549
Но на самом деле это просто оболочка реальных утилит mkfs
 для разных типов файловых систем.

21
00:03:20,260 --> 00:03:30,450
И все они поддерживают свой собственный набор параметров.

22
00:03:34,349 --> 00:03:41,920
Наиболее часто используемые файловые системы в Linux

23
00:03:41,920 --> 00:03:59,440
на сегодняшний день:
* EXT4 -- журналируемая файловая система Linux,

24
00:03:59,440 --> 00:04:11,449
или Fourth Extended File System, которая является
 преемницей Extended File System,

25
00:04:11,449 --> 00:04:27,700
первоначально разработанной в 1992 году Реми Кардом
 для преодоления определенных ограничений файловой системы MINIX.

26
00:04:27,710 --> 00:04:46,150
Файловая система ext4 может поддерживать файлы
 размером до 16 TB и тома размером до 1 exbibyte (EiB),

27
00:04:46,150 --> 00:05:08,640
но в конкретных версиях систем могут быть свои ограничения.

28
00:05:08,640 --> 00:05:11,510
Например для RHEL 7/8 -- 50 TB.

29
00:05:11,510 --> 00:05:33,280
* и XFS -- высокопроизводительная
 64-битная журналируемая файловая система,

30
00:05:33,290 --> 00:05:44,040
созданная Silicon Graphics, Inc (SGI) в 1993 году для их UNIX под названием IRIX.

31
00:05:44,040 --> 00:05:55,920
Хотя XFS масштабируется до exabytes, ограничения
 операционной системы хоста могут быть меньше.

32
00:05:55,920 --> 00:06:15,280
Например -- 500 ТБ для максимального размера файла
 и размера файловой системы для RHEL7

33
00:06:15,280 --> 00:06:22,080
и 1 PB/8 EB для RHEL8.

34
00:06:22,080 --> 00:06:34,060
Обычно ext4 обеспечивает лучшую производительность
 для небольших файловых систем на машинах с ограниченными

35
00:06:34,060 --> 00:06:47,280
возможностями ввода-вывода, в то время как XFS обеспечивает
 лучшую производительность для больших файловых систем

36
00:06:47,280 --> 00:06:51,930
на машинах с высокопроизводительным параллельным вводом-выводом.

37
00:06:51,930 --> 00:07:01,389
Также в XFS проблематичнее уменьшить размер файловой системы.

38
00:07:01,389 --> 00:07:09,181
С помощью опций `mkfs` вы можете установить
 различные параметры для создания файловой системы,

39
00:07:09,181 --> 00:07:19,370
например, оптимизировать ее для хранения больших файлов
 или большего количества файлов меньшего размера.

40
00:07:19,370 --> 00:07:31,540
Как только файловая система создана, мы можем ее "mount" (смонтировать).

41
00:07:31,540 --> 00:07:43,380
В большинстве случаев это происходит автоматически,
 когда вы вставляете в компьютер флешку или SD-карту.

42
00:07:43,389 --> 00:07:53,020
Но в некоторых случаях это нужно делать вручную,
 и вы можете сделать это, выполнив команду `mount`.

43
00:07:54,020 --> 00:08:04,260
Вам просто нужно указать устройство и каталог --

44
00:08:04,260 --> 00:08:13,139
точку монтирования, и после монтирования
 вы увидите содержимое файловой системы

45
00:08:13,139 --> 00:08:19,590
с этого устройства или псевдоустройства в этом каталоге.

46
00:08:19,590 --> 00:08:27,330
А также вы можете выбрать варианты «монтирования».

47
00:08:27,330 --> 00:08:47,000
Например, мы можем смонтировать ISO-образ с опцией `loop`.

48
00:09:11,330 --> 00:09:19,230
А потом мы сможем его размонтировать,

49
00:09:21,230 --> 00:09:29,740
указав в качестве аргумента устройство или каталог монтирования.

50
00:09:31,730 --> 00:09:36,470
Но Linux/UNIX не позволит вам размонтировать

51
00:09:36,470 --> 00:09:39,380
занятое устройство.

52
00:09:39,380 --> 00:09:48,590
Для этого есть много причин (например,
 программа обращается к разделу или открытому файлу),

53
00:09:48,590 --> 00:09:54,150
но самая важная из них -- необходимость предотвратить потерю данных.

54
00:09:54,150 --> 00:10:14,180
Вы можете использовать

55
00:10:14,180 --> 00:10:25,460
команды `fuser` и` lsof`, чтобы найти процессы,
 которые блокируют ваши файловые системы.

56
00:10:25,460 --> 00:10:35,020
В этом вам может помочь опция `-k, --kill` команды `fuser`.

57
00:10:35,020 --> 00:10:42,910
Наконец, мы можем проверить файловую систему.

58
00:10:42,910 --> 00:10:51,710
Для файловых систем с журналированием восстановление
 после отключения электроэнергии не так актуально,

59
00:10:51,710 --> 00:10:56,370
но в некоторых случаях может быть полезно.

60
00:10:56,370 --> 00:11:06,540
В сложной ситуации, например, при повреждении жесткого диска,
во время загрузки системы вы можете получить

61
00:11:06,540 --> 00:11:24,360
сообщение об ошибке, рекомендующее выполнить команду `fsck`.

62
00:11:24,360 --> 00:11:28,921
"File system check" для проверки файловой системы.

63
00:11:28,921 --> 00:11:34,410
Как мы видим, у нас есть много опций

64
00:11:34,410 --> 00:11:46,370
для команды `fsck`, но главная из них -- 'y' (yes).

65
00:11:46,370 --> 00:11:54,810
Это означает -- всегда пытаться исправить любые повреждения
 файловой системы, которые будут обнаружены, автоматически,

66
00:11:54,810 --> 00:12:01,529
в противном случае вы можете получить кучу вопросов по поводу устранения встретившихся неполадок во время проведения процедуры проверки.

67
00:12:01,529 --> 00:12:10,050
После завершения восстановления вы можете найти
 потерянные данные в специальном каталоге «/lost+found»

68
00:12:10,050 --> 00:12:17,790
в корне поврежденной файловой системы.
В этом каталоге может находиться множество каталогов и файлов,

69
00:12:17,790 --> 00:12:24,660
имена которых содержат только числа -- 'i-nodes'.

70
00:12:24,660 --> 00:12:35,740
Об 'i-nodes' см. нашу лекцию «Под капотом -- ссылки и файловая система».

71
00:12:35,750 --> 00:12:43,590
Вы можете переименовать эти каталоги и файлы вручную.
 Например, вы нашли каталог с файлами:

72
00:12:43,590 --> 00:12:52,339
* 'passwd', 'group' и 'shadow' -- это означает, что это '/etc '

73
00:12:52,339 --> 00:13:04,490
* или' sh ',' ls 'и' cp '-- это означает '/ bin '

74
00:13:04,490 --> 00:13:06,480
и так далее ...

75
00:13:06,490 --> 00:13:09,160
И, наконец, несколько слов о свопинге.

76
00:13:09,160 --> 00:13:19,640
Swapping или paging -- это система управления памятью,
с помощью которой компьютер хранит и извлекает

77
00:13:19,640 --> 00:13:29,190
данные из вторичного хранилища для использования в основной памяти.

78
00:13:29,190 --> 00:13:42,930
Это механизм виртуальной памяти, управляемый MMU,
 который применяется в современных операционных системах

79
00:13:42,930 --> 00:13:53,670
для использования вторичного хранилища,
чтобы программы могли задействовать объем памяти,

80
00:13:53,670 --> 00:13:56,110
превышающий размер доступной физической памяти.

81
00:13:56,110 --> 00:14:08,320
Дополнительные сведения см. в лекции « Под капотом -- виртуальная память».

82
00:14:08,320 --> 00:14:20,230
Это означает, что вы можете запускать приложения
 с общим объемом памяти, превышающим

83
00:14:20,230 --> 00:14:23,770
физическую оперативную память вашей системы.

84
00:14:23,770 --> 00:14:34,080
Планировщик отправляет неактивные процессы
в раздел подкачки диска и загружает активные задачи

85
00:14:34,080 --> 00:14:36,170
с диска в память.

86
00:14:36,170 --> 00:14:47,190
Это может снизить общую производительность системы,
 но увеличит возможность запуска приложений.

87
00:14:47,190 --> 00:15:10,040
Основная программа для создания области подкачки -- это `mkswap`:

88
00:15:20,009 --> 00:15:26,540
вам просто нужно указать устройство в качестве аргумента.

89
00:15:26,540 --> 00:15:37,310
Или файл, если вам нужно временное пространство подкачки,
 как это делается в Microsoft Windows.

90
00:15:37,310 --> 00:15:52,720
Затем вы можете включить пространство подкачки
 с помощью команды `swapon`:

91
00:15:52,720 --> 00:16:05,110
После этого вы увидите дополнительное пространство свопинга

92
00:16:05,110 --> 00:16:32,200
с помощью команды` free` или в псевдофайле `/proc/meminfo`.

93
00:16:32,200 --> 00:16:45,839
Вы также можете отключить область свопинга с помощью команды `swapoff`.

94
00:16:48,459 --> 00:16:49,459
ОК.

95
00:16:49,459 --> 00:17:00,730
Но все эти монтирования и свопы будут подключены
 к нашей системе только до перезагрузки.

96
00:17:00,730 --> 00:17:11,749
Чтобы автоматически монтировать их во время загрузки,
 мы должны записать их в таблицу файловых систем.

97
00:17:11,749 --> 00:17:29,780
В большинстве UNIX-подобных систем это файл `/etc/fstab`:

98
00:17:29,780 --> 00:17:39,000
в этом текстовом файле мы можем разместить статическую информацию

99
00:17:39,000 --> 00:17:51,029
о подключении файловых систем и разрешении областей подкачки.

100
00:17:58,519 --> 00:18:02,649
Каждая файловая система описывается в отдельной строке; 

101
00:18:02,649 --> 00:18:13,210
поля в каждой строке разделены табуляцией или пробелами.

102
00:18:13,210 --> 00:18:24,780
* Первое поле (fs_spec) -- это монтируемое блочное
 специальное устройство или удаленная файловая система.

103
00:18:24,799 --> 00:18:34,220
* Второе поле (fs_file) описывает точку монтирования файловой системы.

104
00:18:34,220 --> 00:18:42,320
Для разделов подкачки это поле должно быть указано как «none».

105
00:18:42,320 --> 00:18:48,529
* Третье поле (fs_vfstype) описывает тип файловой системы.

106
00:18:48,529 --> 00:18:55,529
Запись «swap» обозначает файл или раздел,
 который будет использоваться для свопинга.

107
00:18:55,529 --> 00:19:08,859
* Четвертое поле (fs_mntops) описывает параметры монтирования,
 связанные с файловой системой.

108
00:19:08,859 --> 00:19:16,350
* Пятое поле (fs_freq) используется для этих файловых систем
 командой dump, чтобы определить,

109
00:19:16,350 --> 00:19:26,059
какие файловые системы необходимо забэкапить.

110
00:19:26,059 --> 00:19:33,929
* И шестое поле (fs_passno) используется программой fsck (8)
 для определения порядка,

111
00:19:33,929 --> 00:19:39,489
в котором выполняются проверки файловой системы во время перезагрузки.

112
00:19:39,489 --> 00:20:00,950
Поместив некоторую запись в файл fstab,
 вы можете запустить команду `mount`

113
00:20:00,950 --> 00:20:08,700
только с одним из аргументов: устройство или точка монтирования.

