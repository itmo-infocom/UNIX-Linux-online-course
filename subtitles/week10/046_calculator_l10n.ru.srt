1
00:00:05,440 --> 00:00:09,220
$ git checkout Example_8
Что это такое "локализация"?

2
00:00:09,230 --> 00:00:15,850
Локаль -- это основной механизм поддержки
 родных языков в UNIX-подобных системах,

3
00:00:15,850 --> 00:00:48,559
и касательно этого предмета мы сталкиваемся с несколькими
 странными сокращениями: I18N, L10N и даже M17N.

4
00:00:48,559 --> 00:00:51,360
Что бы это значило?

5
00:00:51,360 --> 00:00:57,840
Это означает, что английский не любит длинные слова,
 а в терминологии, связанной

6
00:00:57,840 --> 00:01:07,780
с поддержкой родных языков, используется слишком много букв.

7
00:01:07,780 --> 00:01:14,780
Например -- Multilingualization для прикладного
 программного обеспечения, состоящее из 17 букв

8
00:01:14,780 --> 00:01:26,990
между «M» и «N» и сокращенное до M17N.

9
00:01:26,990 --> 00:01:41,740
M17N выполняется в 2 этапа:
* Internationalization (18 букв между «I» и «N» -- I18N):

10
00:01:41,740 --> 00:01:54,180
реализация возможности обработки
 нескольких локалей программным обеспечением.

11
00:01:54,180 --> 00:02:07,280
* Localization (10 букв между «L» и «N» - L10N):
 добавление определенной локали в программу.

12
00:02:07,280 --> 00:02:09,140
OK.

13
00:02:09,140 --> 00:02:19,789
Давайте посмотрим на наши текущие настройки локали:

14
00:02:19,789 --> 00:02:22,230
$ locale

15
00:02:22,230 --> 00:02:25,680
Как мы видим, с этим связано

16
00:02:25,680 --> 00:02:33,981
множество переменных среды :
* LANG и LC_ALL -- общие языковые настройки.

17
00:02:33,981 --> 00:02:41,890
Эти настройки можно разделить на:
* LC_CTYPE -- Управляет поведением

18
00:02:41,890 --> 00:02:44,129
функций обработки символов.

19
00:02:44,129 --> 00:02:51,009
* LC_TIME -- определяет форматы даты и времени,
 включая названия месяцев, дни недели,

20
00:02:51,009 --> 00:02:57,680
а также общие полные и сокращенные их представления.

21
00:02:57,680 --> 00:03:06,430
* LC_MONETARY -- задаёт денежные форматы,
 включая символ валюты для локали,

22
00:03:06,430 --> 00:03:19,919
разделитель тысяч, положение знака, количество дробных цифр и т.д.

23
00:03:19,919 --> 00:03:28,370
* LC_NUMERIC -- определяет десятичный разделитель
 (или символ системы счисления), разделитель тысяч

24
00:03:28,370 --> 00:03:31,819
и группировку.

25
00:03:31,819 --> 00:03:38,539
* LC_COLLATE -- указывает порядок сопоставления
 и определение регулярного выражения

26
00:03:38,539 --> 00:03:43,889
для локали.

27
00:03:43,889 --> 00:03:53,609
* LC_MESSAGES -- указывает язык, на котором
 написаны локализованные сообщения,

28
00:03:53,609 --> 00:04:10,099
а также положительные и отрицательные
 ответы языкового стандарта ("yes" и "no").

29
00:04:10,099 --> 00:04:21,540
* LC_LTYPE -- указывает механизм макетирования,
 который определяет информацию о языковой визуализации.

30
00:04:21,540 --> 00:04:26,820
Рендеринг языка (или рендеринг текста)
 зависит от атрибутов формы

31
00:04:26,820 --> 00:04:29,290
и направления скрипта.

32
00:04:29,290 --> 00:04:37,630
В языке программирования Cи имя локали C «определяет минимальную среду

33
00:04:37,630 --> 00:04:56,530
для перевода» (стандарт C99 -- и принцип
 остается неизменным, по крайней мере,

34
00:04:56,530 --> 00:04:57,620
с 80-х годов).

35
00:04:57,620 --> 00:05:04,620
Поскольку большинство операционных систем написано на Cи,
 особенно те, которые созданы на основе Unix,

36
00:05:04,620 --> 00:05:17,347
где локали устанавливаются с помощью переменных среды LANG
 и LC_ <что-то>, C в конечном итоге

37
00:05:17,347 --> 00:05:23,660
везде является именем «безопасной» локали.

38
00:05:23,660 --> 00:05:36,260
На платформах POSIX, таких как Unix, Linux и другие,
 идентификаторы локали определены

39
00:05:36,260 --> 00:05:47,510
стандартом ISO и состоят из: `[language[_territory][.codeset][@modifier]]`.

40
00:05:47,510 --> 00:06:18,210
Например, австралийский диалект английского языка с кодировкой UTF-8 --

41
00:06:18,210 --> 00:06:20,650
это en_AU.UTF-8.

42
00:06:20,650 --> 00:06:36,200
Как мы видим, в нашем приложении уже есть l10n.

43
00:06:36,200 --> 00:06:45,840
$ LANG=C calc_ui

44
00:06:45,840 --> 00:06:55,470
$ LANG=en_US.UTF-8 calc_ui

45
00:06:55,470 --> 00:07:07,000
Как мы видим, наше приложение выглядит одинаково
 в базовой локали C или на американском английском.

46
00:07:07,000 --> 00:07:19,960
На русском языке мы видим русский заголовок и кнопки:

47
00:07:19,960 --> 00:07:27,450
$ LANG=ru_RU.UTF-8 calc_ui

48
00:07:27,450 --> 00:08:00,000
В континентальном китайском

49
00:08:00,000 --> 00:08:29,410
$ LANG=zh_CN.UTF-8 calc_ui

50
00:08:29,410 --> 00:08:37,700
и тайваньском китайском мы можем видеть
 разные наборы иероглифов в заголовке:

51
00:08:37,700 --> 00:08:39,940
$ LANG=zh_TW .UTF-8 calc_ui

52
00:08:39,959 --> 00:08:53,149
А для арабского языка

53
00:08:53,149 --> 00:08:59,639
заголовок пишется справа налево:

54
00:08:59,639 --> 00:09:01,899
$ LANG=ar_SY.UTF-8 calc_ui

55
00:09:01,899 --> 00:09:09,529
Выглядит неплохо, но это просто базовая локализация

56
00:09:09,529 --> 00:09:16,589
утилиты `zenity`, используемой` gdialog` .

57
00:09:16,589 --> 00:09:21,020
Нам нужно перевести наши текстовые строки в программе.

58
00:09:21,020 --> 00:09:28,020
И для этого мы можем использовать стандартный
 механизм `gettext`,  который впервые был реализован

59
00:09:28,020 --> 00:09:42,920
Sun Microsystems в 1993 году.

60
00:09:42,920 --> 00:09:48,329
Для работы с ним нам понадобится набор утилит `gettext`:

61
00:09:48,329 --> 00:09:52,060
# yum install gettext
# apt install gettext

62
00:09:52,069 --> 00:09:59,069
У нас есть утилита `gettext` которая переводит текстовые сообщения, переданные ему в качестве аргументов,

63
00:09:59,069 --> 00:10:14,509
в соответствии с настройками переменных среды локали:

64
00:10:14,509 --> 00:10:16,029
$ man gettext

65
00:10:16,029 --> 00:10:19,580
Как мы видим, для этого нам просто нужно добавить

66
00:10:19,580 --> 00:10:29,899
вызов утилиты `gettext` во всех местах, где мы использовали
 текстовую строку в качестве параметра

67
00:10:29,899 --> 00:10:41,880
для `gettext`, и вставить результат выполнения в командные строки,

68
00:10:41,880 --> 00:10:56,779
закавычив команду обратными апострофами.

69
00:10:56,779 --> 00:11:03,400
$ git diff Example_7 Example_8

70
00:11:03,400 --> 00:11:09,399
Изменены всего три строки.

71
00:11:09,399 --> 00:11:28,999
И теперь мы можем получить строки `gettext`
 из исходника с помощью утилиты `xgettext`:

72
00:11:28,999 --> 00:11:43,800
$ make calc_ui.pot xgettext -o calc_ui.pot -L Shell calc_ui

73
00:11:43,800 --> 00:11:56,989
Мы получили файл portable object template `calc_ui.pot`,
 который мы будем использовать как основу для перевода:

74
00:11:56,989 --> 00:11:59,299
$ cat calc_ui.pot

75
00:12:00,299 --> 00:12:09,279
Для примера -- на русский язык:

76
00:12:09,279 --> 00:12:21,279
$ msginit --locale = ru --input = calc_ui.pot

77
00:12:21,279 --> 00:12:29,279
$ cat ru.po

