1
00:00:05,080 --> 00:00:15,360
Как мы помним, у нас есть утилита `passwd`, которую может вызвать
 любой пользователь, чтобы изменить пароль.

2
00:00:15,360 --> 00:00:21,280
Но с другой стороны, у нас не было разрешений
 не только на запись в файл,

3
00:00:21,280 --> 00:00:46,400
в котором хэши паролей находятся `/etc/shadow`, но и на чтение.

4
00:00:46,400 --> 00:00:52,549
Как же простой пользователь может изменить свой пароль?

5
00:00:52,549 --> 00:01:02,760
На самом деле, в UNIX-подобных системах для этого есть специальный трюк.

6
00:01:02,760 --> 00:01:08,030
Давайте посмотрим на права утилиты `passwd`:

7
00:01:08,030 --> 00:01:10,490
$ ls -l /bin/passwd

8
00:01:17,870 --> 00:01:20,110
На месте права на выполнение

9
00:01:20,110 --> 00:01:30,670
для владельца мы видим букву 's' вместо 'x'.

10
00:01:30,670 --> 00:01:43,200
На самом деле это просто особый вид исполняемости,
 который может быть установлен для владельца и группы.

11
00:01:43,200 --> 00:01:58,550
И когда мы запускаем такие файлы, наш исходный UID или GID
 меняется на идентификатор файла.

12
00:01:58,550 --> 00:02:09,140
Процесс стартует с новым эффективным UID или GID,
 равным параметрам файла.

13
00:02:09,140 --> 00:02:20,160
И если мы запустим команду `passwd`, мы станем
 суперпользователем `root` на время работы этой программы.

14
00:02:20,160 --> 00:02:27,610
В этом состоянии мы можем читать и писать в `/etc/shadow`.

15
00:02:27,610 --> 00:02:42,319
Мы можем установить или отключить suid и sgid
 в символьном режиме, используя символ 's'.

16
00:02:42,319 --> 00:02:47,890
В двоичном режиме файл выглядит так:

17
00:02:47,890 --> 00:02:56,880
$ stat -c "% a% A% n" /bin/passwd
4755 -rwsr-xr-x /bin/passwd

18
00:02:56,880 --> 00:03:14,840
$ stat -c "% a% A% n" /bin/crontab
2755 -rwxr-sr-x /bin/crontab

19
00:03:14,850 --> 00:03:31,000
Другой вопрос -- есть ли идеи по поводу реализации, например, утилиты `ps`?

20
00:03:31,000 --> 00:03:49,020
На самом деле это кажется довольно простым --
 нам просто нужно открыть специальный файл '/dev/mem',

21
00:03:49,020 --> 00:04:05,989
прочитать из него (на самом деле -- из памяти)
 текущую таблицу процессов и распечатать ее в stdout.

22
00:04:05,989 --> 00:04:13,670
Но для этого у нас нет разрешения на чтение памяти:

23
00:04:13,670 --> 00:04:16,620
$ ls -l /dev/mem
crw-r----- 1 root kmem 1, 1 Sep 1 21:39 /dev/mem

24
00:04:16,630 --> 00:04:26,490
И кода-то утилита `ps` имела бит `s`
 для того что бы такое чтение осуществлять.

25
00:04:26,490 --> 00:04:29,490
А что сегодня?

26
00:04:29,490 --> 00:04:42,340
$ ls -l /bin/ps
-rwxr-xr-x 1 root root 137688 Feb 27 2020 /bin/ps

27
00:04:42,349 --> 00:04:47,340
У нас сейчас нет бита setuid.

28
00:04:47,340 --> 00:04:48,340
Почему?

29
00:04:48,340 --> 00:04:55,340
Потому что в большинстве UNIX-подобных систем нынче у нас есть специальная файловая система `/proc`, которая представляет собой

30
00:04:55,340 --> 00:05:04,249
некую кроличью нору в ядро.

31
00:05:04,249 --> 00:05:15,190
Она была реализована Томом Дж. Киллианом для UNIX 8th Edition в 1984 году.

32
00:05:15,190 --> 00:05:21,789
Все процессы можно рассматривать как подкаталоги в каталоге `/proc`,

33
00:05:21,789 --> 00:05:31,560
и у нас более нет надобности в suid бите

34
00:05:31,560 --> 00:05:37,249
для чтения данных, связанных с процессом.

35
00:05:37,249 --> 00:05:43,089
Такая нетривиальная модификация ядра системы дает нам `ps` без бита suid,

36
00:05:43,089 --> 00:05:50,780
а это не так уж и мало.

37
00:05:50,780 --> 00:05:51,280
Потому что каждый бит suid -- это потенциальная дыра в безопасности,

38
00:05:51,280 --> 00:06:10,500
и ежедневная задача системного администратора --
 искать новые 's' биты в исполняемых файлах.

39
00:06:10,500 --> 00:06:16,539
Для автоматического ежедневного мониторинга такой задачи
 может оказаться полезной утилита `logwatch`.

40
00:06:16,539 --> 00:06:25,659
И, наконец, первый бит специальных прав доступа -- это sticky bit.

41
00:06:25,659 --> 00:06:32,069
Давайте посмотрим на права каталога для временных файлов -- `/tmp`:

42
00:06:32,069 --> 00:06:42,160
$ ls -l /
drwxrwxrwt 25 root root 20480 Sep 6 21:23 tmp

43
00:06:43,180 --> 00:06:47,340
Итак, мы можем увидеть разрешения исполняемого файла

44
00:06:47,340 --> 00:06:52,779
для владельца и группы.

45
00:06:52,779 --> 00:07:00,389
Кстати, что означает «исполняемый» для каталога?

46
00:07:00,389 --> 00:07:07,109
Как это ни странно, но это разрешение означает --
 вы можете перейти в этот каталог,

47
00:07:07,109 --> 00:07:13,409
например, с помощью команды `cd`.

48
00:07:13,409 --> 00:07:21,419
А также мы видим разрешение 't' для каталога '/tmp'.

49
00:07:21,419 --> 00:07:31,869
Как правило, каталог `/tmp` является общедоступным --
 все пользователи имеют все права доступа к нему.

50
00:07:31,869 --> 00:07:41,819
Конечно, они не могут изменять файлы или каталоги,
 принадлежащие другим пользователям,

51
00:07:41,819 --> 00:07:48,819
если у них нет таких разрешений, но они могут удалить их,
 потому что у всех есть все разрешения

52
00:07:48,819 --> 00:08:00,409
на изменение этого каталога.

53
00:08:00,409 --> 00:08:13,729
А разрешение файла 1000 или 't' в символьном режиме означает --
 только владелец чего-либо

54
00:08:13,729 --> 00:08:18,149
может удалить его в каталоге, где этот бит установлен.

