1
00:00:06,740 --> 00:00:13,540
Формат текстовых данных на первый взгляд
 кажется довольно простым и универсальным --

2
00:00:13,540 --> 00:00:26,360
в простейшем случае у нас просто есть набор байтов,
 закодированных стандартной таблицей символов ASCII.

3
00:00:26,360 --> 00:00:37,370
Но если вы посмотрите на спецификацию языка C
 функции `fopen` в ОС UNIX и MS,

4
00:00:37,370 --> 00:00:43,730
вы увидите интересные различия.

5
00:00:43,730 --> 00:00:55,239
В системах MS вы найдете указание режима перевода на новую строку:

6
00:00:55,239 --> 00:01:01,469
* `t` -- Открыть в текстовом (транслированном) режиме.

7
00:01:01,469 --> 00:01:08,469
* `b` -- открыть в бинарном (нетранслированном) режиме;
 трансляции, затрагивающие символы

8
00:01:08,469 --> 00:01:14,680
возврата каретки и перевода строки, не используются.

9
00:01:14,680 --> 00:01:20,130
Что означает трансляция в этом контексте?

10
00:01:20,130 --> 00:01:29,770
В UNIX-подобных системах нет разницы
 между текстовыми и двоичными данными.

11
00:01:29,770 --> 00:01:38,430
Чтобы понять это, нам нужно вернуться к началам --
 к интерфейсу TTY.

12
00:01:38,430 --> 00:01:41,460
Более того -- к старой доброй пишущей машинке.

13
00:01:41,460 --> 00:01:48,460
Возврат каретки -- это реальная операция, выполняемая
 на пишущей машинке, которая используется для возврата бумаги

14
00:01:48,460 --> 00:02:10,110
в крайнее правое положение, чтобы механизм печати
 был выровнен с левой стороной бумаги.

15
00:02:14,730 --> 00:02:21,730
Для TTY с электрическим приводом эту работу выполняет
 специальный код ASCII -- возврат каретки (carriage return)

16
00:02:21,730 --> 00:02:37,180
определяется как 13 десятичное (или шестнадцатеричное 0D),
 или '\r' в нотации языка Си.

17
00:02:37,180 --> 00:02:46,140
Другой символ -- это перевод строки (line feed) --
 10 (или шестнадцатеричный 0A) и '\n' в нотации языка C.

18
00:02:46,140 --> 00:03:02,830
Несмотря на то, что мы нажимали только ENTER,
 то есть -- LF и UNIX, и MS OS обработали это по-разному.

19
00:03:02,830 --> 00:03:17,110
В UNIX обслуживание этого действия выполняет драйвер устройства --
 если мы отправим ему LF, но для правильного окончания строки

20
00:03:17,110 --> 00:03:27,319
требуется CR, драйвер просто добавит его в текстовый поток устройства.

21
00:03:27,319 --> 00:03:36,010
В текстовый файл будут помещены только символы,
 которые мы набирали на клавиатуре --

22
00:03:36,010 --> 00:03:41,890
в конце строки окажется только LF.

23
00:03:41,890 --> 00:03:51,930
Но в системах MS при работе с текстовыми файлами
 выполняются специальные действия.

24
00:03:51,930 --> 00:03:58,250
Если мы будем работать с этим типом файлов,
 операционная система автоматически

25
00:03:58,250 --> 00:04:06,930
добавит в текст CR перед LF.

26
00:04:06,930 --> 00:04:32,700
Это может вызвать некоторые неочевидные ошибки,
 и у нас есть такие утилиты, как dos2unix и unix2dos

27
00:04:32,700 --> 00:04:35,370
для преобразования между этими форматами.

28
00:04:35,370 --> 00:04:46,540
Но в некоторых случаях проблемы, связанные с дизайном MS,
 таким простым способом не решаются.

29
00:04:46,540 --> 00:04:55,010
История из реальной жизни: когда-то давным-давно
 в Физико-техническом институте наши студентки

30
00:04:55,010 --> 00:04:55,510
при написании диплома разработали
 систему обработки изображений для работы

31
00:04:55,510 --> 00:05:05,490
с данными с голографического интерферометра.

32
00:05:05,490 --> 00:05:16,760
Эта система создана по принципу KISS -- из очень простых составных частей.

33
00:05:16,760 --> 00:05:23,560
Они разработали различные фильтры изображений
 для очистки изображения, для выделения

34
00:05:23,560 --> 00:05:28,790
интерферометрических линий, для построения карты плотности.

35
00:05:28,790 --> 00:05:36,030
Все эти простые программы соединялись конвейерами shell
 и просто отправляли отфильтрованные

36
00:05:36,030 --> 00:05:44,440
данные изображения из одной программы обработки в другую
 через стандартные потоки ввода-вывода.

37
00:05:44,440 --> 00:05:44,940
Такой подход давал довольно простой механизм,
 позволяющий поиграть с набором фильтров

38
00:05:44,940 --> 00:05:56,320
и их параметрами и успешно написать диплом.

39
00:05:56,320 --> 00:06:06,210
Но однажды индийские клиенты попросили нас предоставить
 наш интерферометр, но им нужна была программа,

40
00:06:06,210 --> 00:06:08,040
которая работала бы в Windows.

41
00:06:08,040 --> 00:06:18,400
Не проблема, мы знаем, что ОС Microsoft унаследовали от Unix
 механизм перенаправления

42
00:06:18,400 --> 00:06:24,430
потоков ввода-вывода и объединения их через программные каналы.

43
00:06:24,430 --> 00:06:34,910
Мы просто перекомпилировали исходный код C в Windows
 и запустили наши сценарии как командные файлы.

44
00:06:34,910 --> 00:06:38,440
И -- ничего не работает...

45
00:06:38,440 --> 00:06:40,220
Почему?

46
00:06:40,220 --> 00:06:51,020
Ищем проблему и видим -- ОС работает со стандартными
 потоками ввода-вывода и конвейерами

47
00:06:51,020 --> 00:06:53,190
в текстовом режиме!

48
00:06:53,190 --> 00:07:00,770
И вставляет CR перед LF -- в бинарные данные изображения.

49
00:07:00,770 --> 00:07:03,800
И все данные получаются битые.

50
00:07:03,800 --> 00:07:11,800
Для решения проблемы пришлось переписать
 всю систему в стандартном стиле Windows --

51
00:07:11,800 --> 00:07:15,180
как большое монолитное приложение.

