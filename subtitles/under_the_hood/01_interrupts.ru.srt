1
00:00:06,560 --> 00:00:16,320
Мы говорили о ядре как о некой волшебной программе,
которая стартует при загрузке и продолжает работать,

2
00:00:16,320 --> 00:00:28,560
пока ваш компьютер включен. Но всё же что она делает?
Для того что бы понять это, 

3
00:00:28,560 --> 00:00:39,520
нам надо окинуть взором эволюцию ПО
компьютерных систем. С того самого момента, когда

4
00:00:39,520 --> 00:00:49,840
компьютерные программы только начали создаваться,
немедленно встал вопрос -- как переиспользовать написанное?

5
00:00:51,440 --> 00:01:04,400
И тут срабатывает хорошо известный закон Парето --
когда вам нужно что-то новое, то скорее всего это уже

6
00:01:06,880 --> 00:01:18,000
кем-то реализовано процентов на 80
и вам нужно дописать или переписать только 20%.

7
00:01:18,720 --> 00:01:24,960
Вы, конечно, можете использовать старый добрый метод
"cut and paste" (вырезать и приладить),

8
00:01:25,920 --> 00:01:35,600
но он часто является источником ошибок и багов,
особенно в больших и сложных системах.

9
00:01:36,960 --> 00:01:39,840
Чтобы решить эту проблему,

10
00:01:41,360 --> 00:01:50,800
некоторые из наиболее часто используемых функций
были скомпонованы в программные библиотеки,

11
00:01:50,800 --> 00:02:04,560
которые обычно представляют собой просто архивы объектных файлов скомпилированных программ. Затем вы можете слинковать некоторые из этих

12
00:02:04,560 --> 00:02:12,880
объектных файлов со своим исполняемым файлом и использовать функции, разработаные и протестированные другими в вашей программе.

13
00:02:14,320 --> 00:02:20,320
Но с развитием компьютерной индустрии и повсеместным использованием

14
00:02:22,000 --> 00:02:29,680
компьютерных систем возникает вопрос
о более стабильном программном ядре для работы 

15
00:02:29,680 --> 00:02:37,040
с внешними устройствами и ресурсами системы,
для регулирования доступа к ним

16
00:02:37,040 --> 00:02:44,400
программ и пользователей. И решение пришло в виде прерываний.

17
00:02:45,680 --> 00:02:54,240
Что такое прерывание? По словам Дейкстры, «это великое изобретение,

18
00:02:55,040 --> 00:03:02,320
но вместе с тем -- и ящик Пандоры». Более формально, прерывание --

19
00:03:02,960 --> 00:03:09,680
это реакция процессора на событие, требующее внимания

20
00:03:10,400 --> 00:03:18,160
со стороны программного обеспечения. Исторически прерывания
были созданы прежде всего для решения проблем,

21
00:03:18,720 --> 00:03:32,160
обнаруженных аппаратным обеспечением. Например,
арифметическое переполнение, реализованное для UNIVAC I (1951).

22
00:03:32,160 --> 00:03:40,240
Прерывания широко используются для обработки
арифметических ошибок, попыток некорректного доступа к памяти  

23
00:03:40,240 --> 00:03:49,680
и, наконец, для работы с устройствами. Технически прерывания --
это просто события, которые переключают

24
00:03:51,440 --> 00:04:00,160
процессор с выполнения текущей программы на выполнение
так называемой программы-обработчика прерываний,

25
00:04:00,160 --> 00:04:14,840
адрес, которой помещается в специальную таблицу,
помещенную в фиксированную область памяти --

26
00:04:24,240 --> 00:04:31,680
таблицу векторов прерываний. Для каждого типа прерывания

27
00:04:33,040 --> 00:04:43,600
используется специальная позиция в этой таблице
с адресом соответствующей программы-обработчика.

28
00:04:50,640 --> 00:04:55,280
Когда генерируется запрос прерывания,

29
00:04:55,280 --> 00:05:08,880
процессор сохраняет текущее состояние регистров процессора
и переключает программный счетчик

30
00:05:09,840 --> 00:05:33,920
на этот обработчик. В конце программы-обработчика
выполняется специальная машинная инструкция --

31
00:05:33,920 --> 00:05:45,520
восстанавливается выход из прерывания
и состояние процессора до вызова прерывания.

32
00:05:50,480 --> 00:05:57,920
Но настоящий прорыв произошел, когда были изобретены
программные прерывания (software interrupts).

33
00:05:59,520 --> 00:06:08,000
Впервые они были реализованы в IBM 704 (1955 г.)
как функция отладки, называемая «перехватом передачи».

34
00:06:09,680 --> 00:06:21,600
Но постепенно выяснилось, что это позволяет реализовать

35
00:06:21,600 --> 00:06:27,200
функциональность процессора с виртуальным набором команд. Например,

36
00:06:27,920 --> 00:06:36,160
мы можем вызвать только одну машинную команду, чтобы открыть файл.
И это команда --программное прерывание.

37
00:06:36,800 --> 00:06:42,160
Существуют разные команды для разных
компьютерных архитектур: INT на Intel,

38
00:06:43,200 --> 00:06:52,000
SVC / SWI на ARM, TRAP на SPARC и т. Д.
На PDP 11 имелось более одного программного

39
00:06:52,000 --> 00:07:03,040
прерывания в наборе команд -- EMT для DEC OS и SYS под UNIX.
Но все они делают одно

40
00:07:03,040 --> 00:07:15,920
и то же -- мы переходим по вектору прерывания
и запускаем соответствующую программу-обработчик.

41
00:07:15,920 --> 00:07:26,640
Такая команда со стороны API программирования выглядит как функция,

42
00:07:28,240 --> 00:07:34,640
называемая «системный вызов».
И когда мы вызываем такую функцию из программы,

43
00:07:34,640 --> 00:07:44,240
она выглядит как отдельная машинная инструкция
на ассемблере, но может запускать множество других функций

44
00:07:44,240 --> 00:07:51,680
и взаимодействовать со многими системными службами.
Например, когда мы выполняем системный вызов

45
00:07:52,640 --> 00:08:01,440
«открыть файл», который размещен на сетевом файловом сервере,
мы фактически осуществляем поиск

46
00:08:01,440 --> 00:08:09,680
в дереве файловой системы, вызывая функции VFS,
перенаправляя на соответствующий драйвер

47
00:08:09,680 --> 00:08:15,760
сетевой файловой системы, отправляя сетевые запросы
сетевыми драйверами стека TCP/IP через

48
00:08:15,760 --> 00:08:24,000
сетевое устройство, подключенное к сети файлового сервера,
взаимодействуя с серверной частью

49
00:08:24,000 --> 00:08:32,080
сетевой файловой системы на сервере, разыскивая нужный нам
файл в локальной файловой системе сервера с помощью

50
00:08:32,080 --> 00:08:42,320
его VFS, а затем обращаясь к нему через драйвер
устройства жесткого диска, на котором этот файл размещается.

51
00:08:43,680 --> 00:08:53,920
По сути дела, вся эта черная магия осуществляется с помощью
одной команды, которая может выглядеть как виртуальная  

52
00:08:53,920 --> 00:09:03,760
команда «открыть файл» на вашем процессоре.
В общем, ОС -- это просто набор

53
00:09:03,760 --> 00:09:10,480
обработчиков прерываний, которые реализуют
такой набор виртуальных инструкций, специфичных

54
00:09:10,480 --> 00:09:20,200
для этой ОС, и взаимодействуют с оборудованием.
Например, как мы увидим далее,

55
00:09:20,720 --> 00:09:32,320
с системным таймером для переключения контекста
процессора во время работы многозадачной системы.

