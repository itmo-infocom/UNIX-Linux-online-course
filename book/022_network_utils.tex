\section*{Basic Network Utilities} % ## Basic network utilities

From the very beginning of the development of computer communication
technologies, UNIX has been closely associated with them. Historically,
the first worldwide network to operate over conventional dial-up telephone
lines was created in the late 1970s at At\&T and called \cmd{UUCP}~---
``UNIX to UNIX copy''. And in 1979, two students at Duke University,
\struct{Tom Truscott} and \struct{Jim Ellis}, originated the idea of
using Bourne shell scripts to transfer news and mail messages on a serial line
UUCP connection with nearby University of North Carolina at Chapel Hill.
Following public release of the software in 1980, the mesh of UUCP hosts
forwarding on the Usenet news rapidly expanded and named UUCPnet.

Technically, in the beginning, these could be dial-up modems, simply attached
to the telephone tubes with suction cups which makes connects on hundreds of
bits per second speed with very unstable connection. Even so, on this stage
UNIX offered a fully functional network with the ability to remotely execute
commands and transfer data over a complex mesh network topology.

UUCP provided just two main utilities:
\begin{itemize}
\item \cmd{uucp}~--- system-to-system copy
\item \cmd{uux}~--- remote command execution
\end{itemize}

It was a very simple addressing scheme with no dynamic routing or anything
similar, and the command to do something on a remote machine with files hosted
on other machines might look like this:
\begin{code}{mverb}
uux 'diff sys1!~user1/file1 sys2!~user2/file2 >!file.diff'
\end{code}
Fetch the two named files from system sys1 and system sys2 and execute
\cmd{diff} putting the result in file.diff in the current directory.
It's funny, this addressing is still supported, for example,
by the `\cmd{sendmail}' mail system, which adds some complexity.

\subsection*{Traditional Network Utilities} % ## Traditional network utilities

In the world of TCP/IP Network, other programs have been developed that are
still relevant in some cases, classical Internet programs:
\begin{itemize}
\item \cmd{telnet}~--- user interface to the TELNET protocol
\item \cmd{ftp}~--- ARPANET file transfer program
\item \cmd{mail}~--- send and receive mail
\end{itemize}
Again we have a tool for remote execution and a tool for data transfer.

Generally, telnet just gives us a connection to the TELNET protocol server:
\begin{code}{mverb}
man telnet
\end{code}
It's just a CLI for another host and this protocol still used for access
to some hardware devices. Moreover, you can use it for debugging by connecting
to other servers by choosing of TCP server's port. For example HTTP:
\begin{code}{mverb}
$ telnet google.com 80
Trying 173.194.73.101...
Connected to google.com.
Escape character is '^]'.
GET /index.html HTTP/1.1
\end{code} % $
To switch to telnet command mode, press the ``\struct{Ctrl-]}'' key.
Here we can ask for help and exit, for example, if the program on the other
side is frozen:
\begin{code}{mverb}
telnet> h
Commands may be abbreviated.  Commands are:
close			close current connection
logout		forcibly logout remote user and close the connection
display	display operating parameters
mode				try to enter line or character mode ('mode ?' for more)
open				connect to a site
quit				exit telnet
send				transmit special characters ('send ?' for more)
set					set operating parameters ('set ?' for more)
unset			unset operating parameters ('unset ?' for more)
status		print status information
toggle		toggle operating parameters ('toggle ?' for more)
slc					set treatment of special characters

z							suspend telnet
environ	change environment variables ('environ ?' for more)
telnet> q
Connection closed.
\end{code}

FTP or File Transfer Protocol is another well-known part of the networked
world of the Internet. It is still supported by some internet servers and
is also built into some devices. We can access the FTP server through a regular
web browser as well as through the \cmd{ftp} utility:
\begin{code}{mverb}
man ftp
\end{code}

In some cases, the latter variant is preferable, because, for example,
we may want to restore a file or upload/download many files. First, we have
to log into the FTP server. Let's try to do this as an anonymous user:
\begin{code}{mverb}
$ ftp ftp.funet.fi
Name (ftp.funet.fi:user): ftp
331 Any password will work
Password:
\end{code} % $

In this case any password will work, but often FTP-server wait email
address as a password.

FTP has its own command line interface where we can ask for help:
\begin{code}{mverb}
ftp> ?
Commands may be abbreviated.  Commands are:

!       dir         mdelete  qc        site
$       disconnect  mdir     sendport  size
account exit        mget     put       status
append  form        mkdir    pwd       struct
ascii   get         mls      quit      system
bell    glob        mode     quote     sunique
binary  hash        modtime  recv      tenex
bye     help        mput     reget     tick
case    idle        newer    rstatus   trace
cd      image       nmap     rhelp     type
cdup    ipany       nlist    rename    user
chmod   ipv4        ntrans   reset     umask
close   ipv6        open     restart   verbose
cr      lcd         prompt   rmdir     ?
delete  ls          passive  runique
debug   macdef      proxy    send
ftp>
\end{code} % $

We can first determine our current directory, and as we understand it,
we have two current directories: remote and local. We can get the remote
directory with the standard `\cmd{pwd}' command. To get the current local
directory we can use the same command preceded by an exclamation mark.
This means~--- call this command on the local computer. You may change
directory remotely by `\cmd{cd}' and local directory by `\cmd{lcd}'.

We can get a list of remote directoriy using the well-known `\cmd{ls}' command.
And what about local `\cmd{ls}'? Yes~--- just preced it by an exclamation mark.
If you have sufficient permissions, you can download file by `\cmd{get}' command
and upload by `\cmd{put}', but only a single file. If you want to work
with multiple files, you will need to use the `\cmd{mget}'/`\cmd{mput}' commands.

In this case, it makes sense to disable the questions about confirming
operations using the prompt command. Also switching to binary mode using
the bin command can be important for the Microsoft client system.
Otherwise, you may receive a corrupted file.

Finally, you can use the `\cmd{reget}' command to try to continue downloading
the file after an interrupted transfer. And the `\cmd{hash}' command toggle
the `hash' printing for each transmitted data block, which can be informative
if the connection to the server is poor.

Another useful scripting program is `\cmd{mail}', which is a simple command
line client for sending email:
\begin{code}{mverb}
$ mail user@localhost
Subject: test
This is a test!
.
\end{code} % $
The mail message must end with one `dot' per line.
