\documentclass[12pt]{report}
\usepackage{cmap}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage[english]{babel}
%\usepackage[english,russian]{babel}

\usepackage{hyperref}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{enumerate}
%\usepackage{enumitem}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{textcomp}

\usepackage{listings}

\usepackage{comment}

\newcommand{\struct}[1]{\textcolor{blue}{#1}}
\newcommand{\Rim}[1]{\uppercase\expandafter{\romannumeral#1}}
\newcommand{\cmd}[1]{\textcolor{blue}{\tt #1}}

\definecolor{mverb}{HTML}{C0E8F8}

\lstnewenvironment{code}[1]{%
  \lstset{backgroundcolor=\color{#1},
  frame=single,
  showlines=true,
  framerule=0pt,
  basicstyle=\ttfamily,
  columns=fullflexible}}{}

\parskip5pt
\parindent0pt

\title% (optional, use only with long paper titles)
{UNIX AND LINIX\\IN INFOCOMMUNICATION\\Week 3}

\author % (optional, use only with lots of authors)
{O.~Sadov%,\\ \texttt{tit@astro.spbu.ru}
}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

%%%\institute{ITMO}
%  Университет Информационных Технологий, Механики и Оптики\\
%  кафедра Телекоммуникационных Систем

% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date% (optional, should be abbreviation of conference name)
{Aug 10, 2020 10:33 PM}


\begin{document}
\maketitle

\section*{Utilities}

All commands typed on the command line or executed in a command file are
either commands built into the interpreter or external executable files.
The set of built-in commands is quite small, which is determined by the
basic concept of UNIX - the system should consist of small programs that
perform fairly simple well-defined functions that communicate with each
other via a standard interface.

A rich set of standard utilities is a good old tradition for UNIX-like
systems. The shell and the traditional set of UNIX utilities,
is a \struct{POSIX} standard.

As we discussed earlier, we have different branches of development of UNIX-like systems with different types of utilities:
\begin{itemize}
\item \struct{BSD}-like dating back to the original UNIX implementations;
\item \struct{SYSV} based systems;
\item \struct{GNU} utilities.
\end{itemize}

Some command syntax was changed by the USL with the introduction of SYSV,
but on most commercial UNIX a set of older commands was still included
for compatibility with earlier BSD-based versions of UNIX from the same vendor.
\struct{GNU} utilities often combine both syntaxes and add their own
enhancements to traditional utilities. And now the GNU toolkit has become
the de facto standard.

Executable files on UNIX-like systems do not have any file name extension
requirements as they do on Windows. The utility executable can have any name,
but must have execute permission for the user who wants to run it.

A standard utility can have options, argument of options, and operands.
Command line arguments of programs are mainly parsed by the getopt()
function, which actually determines the form of the parameters when
the command is invoked. This is an example of utility's synopsys description:

\begin{code}{mverb}
utility_name[-a][-b][-c option_argument] \
                          [-d|-e][-f[option_argument]][operand...]
\end{code}

\noindent
\begin{enumerate}
\item The utility in the example is named \struct{\cmd{utility\_name}}.
It is followed by \struct{options}, \struct{option-arguments}, and \struct{operands}.
The arguments that consist of <hyphen-minus> characters and single letters or
digits, such as `a', are known as ``options'' (or, historically, ``flags'').
Certain options are followed by an ``option-argument'', as shown with
[-c option\_argument]. The arguments following the last options and
option-arguments are named ``operands''.

The GNU \cmd{getopt()} function supports so-called long parameters, which start
with two dashes and can use the full or abbreviated parameter name:
\begin{code}{mverb}
utility_name --help
\end{code}
\item \struct{Option-arguments} are shown separated from their options by
<blank> characters, except when the option-argument is enclosed in the
'\struct{[}' and '\struct{]}' notation to indicate that it is optional.

In GNU getopt's long options also may be used the 'equal' sign between
option and option-argument:
\begin{code}{mverb}
utility_name --option argument --option=argument
\end{code}
\item When a utility has only a few permissible options, they are
sometimes shown individually, as in the example. Utilities with many
flags generally show all of the individual flags (that do not take
option-arguments) grouped, as in:
\begin{code}{mverb}
utility_name [-abcDxyz][-p arg][operand]
\end{code}
Utilities with very complex arguments may be shown as follows:
\begin{code}{mverb}
utility_name [options][operands]
\end{code}
\item Arguments or option-arguments enclosed in the '[' and ']'
notation are optional and can be omitted. Conforming applications shall
not include the '[' and ']' symbols in data submitted to the utility.
\item Arguments separated by the '\struct{|}' ( <vertical-line>) bar notation
are mutually-exclusive.
\begin{code}{mverb}
utility_name [-a|b] [operand...]
\end{code}
Alternatively, mutually-exclusive options and operands may be listed with
multiple synopsis lines. For example:
\begin{code}{mverb}
utility_name [-a] [-b] [operand...]
utility_name [-a] [-c option_argument] [operand...]
\end{code}
\item Ellipses ( ``\struct{...}'' ) are used to denote that one or more
occurrences of an operand are allowed.
\end{enumerate}

\section*{System manuals}
%by Oleg Sadov — last modified Aug 10, 2020 10:37 PM

The easiest way to get information about the use of a command is with
the \struct{-h} option or \struct{-\mbox{}-help} for GNU long options.

Also since its inception, UNIX has come with an extensive set of
documentation. Some information is often found in the \cmd{/usr/doc} or
\cmd{/usr/local/doc} or \struct{/usr/share/doc} directories as text files.

But the cornerstone of the Unix help system is the man command. And the man
in this case is not about gender~--- it is just an abbreviation for manual.
\begin{code}{mverb}
man man
\end{code}
The \cmd{man} command has been traditional on UNIX since its inception,
was created in the teletype era and still works great on all types of equipment.
And in the synopsis of the man command, we see two worlds,
two UNIX utility systems: BSD and SYSV.

And at first we can see the different command syntaxes:
\begin{code}{mverb}
SYSV~--- \cmd{man [-t] [-s section] name}
GNU, BSD~--- \cmd{man [-t] [section] name}
\end{code}

Parts of the man page are more or less the same:\\
NAME, SYNOPSIS, DESCRIPTIONS, FILE, SEE ALSO, DIAGNOSTIC, BUGS

The \struct{minus S} option with some integer parameter of man command
in the SYSV variant denotes a section of real paper manuals supplied with
the OS by vendor. For GNU/BSD flavors, use only the section number.
Section numbers are also different.\\
.... Pres-n p.3\\
....

Let's look for example to well known C-languge function `printf' manual page.
But
\begin{code}{mverb}
man printf
\end{code}
``man printf'' shows us the man page for the shell command, not the C~function.
To see the manual for the C printf function, we must run:
\begin{code}{mverb}
man 3 printf
\end{code}

To view a list of printf-related manual pages, we must run:\\
\cmd{whatis}~--- search the whatis database (created by makewhatis)
for complete words\\
and\\
`\cmd{man -k}' or `\cmd{apropos}'~--- search the whatis database for strings.

The databases should be created by the `makewhatis' program,
which is usually started at night by the cron service. If you have a freshly
installed system and want to run any command related to the whatis database,
you posibly need to start the \cmd{makewhatis} program manually.

OK~--- let's look to real man page:
\begin{code}{mverb}
zless /usr/share/man/man1/man.1.gz
\end{code}

Troff(short for ``typesetter roff'')/nroff(newer ``roff'') is an implementation
of a text formatting program, traditional for UNIX systems, using a plain text
file with markup. It is ideologically based on the RUNOFF MIT program,
developed in 1964, and after a series of source code losses and rewrites,
a C-based implementation was re-implemented in 1975. Under the name Troff,
it was accepted for use on the UNIX system and, of course,
into the AT\&T patent department.

See -- \href{http://manpages.bsd.lv/history.html}{http://manpages.bsd.lv/history.html}

The main advantage of this tool was portability and the ability to generate
printouts for various devices, from a common ASCII printer to high-quality
typographic photosetters. Creating new technologies such as PostScript printers
simply adds the appropriate output drivers for the markup renderer.
Compared to the now better known WYSIWYG systems, such systems have better
portability between platforms and higher typing quality. Moreover, such systems
are more focused on the programmatic creation of printed documents
without human intervention.

Let's take a look at an example of manually rendering the man page that
was hidden under the hood of the man command:
\begin{code}{mverb}
$ zcat /usr/share/man/man1/man.1.gz | tbl | eqn -Tascii | \
                                                   nroff -man | less
\end{code} % $

It's just a software pipeline in which we unpack the compressed TROFF source,
go through the TROFF preprocessor for tables and math equations,
pass a troff variant named `nroff' to output a text terminal, and finally
pass a text pager/viewer named `less'.

What is it viewer? In the TTY interface, the man command seems like
a good one~--- when you run it, you get paper manuals that you can combine
into a book, put on a shelf, and reread as needed. On a full-screen terminal~---
before, \cmd{Ctrl-S}(stop)/\cmd{Ctrl-Q}(repeat) was enough for viewing,
because at first the terminals were connected at low speed (9600 bits per
second for ex.), and now special programs were used~--- viewers.

And in fact, when you run the ``\cmd{man}'' command, you see just a viewer's
interface, in most cases it is ``\cmd{less}''. We will discuss viewers further,
but in a nutshell, the most commonly used of them the `\cmd{less}' handles
the \struct{UP/DOWN} keys normally, exiting a program~--- the `\struct{q}' key
means `quit'.

Well. It looks great, but the man-style documentation representation has
certain limitations: it is only a textual representation without any
useful functions invented after that time~--- for example, impossibility of
using hypertext links.

To improve it, the GNU Project has created an information system that
also works on all types of alphanumeric terminals, but with hypertext support.
For many GNU utilities, the corresponding help files are in info format,
and the man pages recommend that you refer to \cmd{info}.

Info has its own user interface and the best way to learn it is to simply
run the `\cmd{info info}' command. The internal source of ``info'' is the text
markup files in texinfo format. From such files are generated text files
for viewing on terminals, and also by the \TeX\ typesetting system
generated documentation for printing.

\TeX\ is another typesetting system (or ``formatting system'') that was
developed and mostly written by Donald Knuth, released in 1978. \TeX\ and
its \LaTeX\ extension are very popular in the scientific world as a means
of typing complex mathematical formulas.

OK. But the inability to use graphic illustrations and any kind of multimedia
context remained relevant. And in the past, almost every commercial UNIX system
vendor created their own help system, which includes both hypertext support
and graphics for ex., and worked in the X~Window System.

But now with the advent of HTML (yet another text markup language), such
reference information began to be provided in this format directly on
the system or on WWW servers. Often these HTML pages or print-ready PDF versions
are simply generated from some content oriented markup such as DocBook or
LinuxDoc.

\section*{Some utils}
%by Oleg Sadov — last modified Aug 21, 2020 05:00 PM

OK. But you can get useful information not only from the `info' utility.

\subsection*{OS variant}

Ok, we just logged in. First, let's try to determine which part of
the UNIX-like universe we are in.

\subsection*{Uname}

{\struct{\bf uname}}~--- print system information, in most simple case~---
just name of kernel. With ``\cmd{all}'' flag we will get more inforamtion.
And for what needs can such information be used, besides simple curiosity?
The answer is simple~--- it can be used to create portable applications or
some kind of administrative scripts for various types of UNIX-like systems.
You can use it in your installation or shell configuration scripts to select
different binaries and system utilities according to your specific computer
architecture and OS.

This works well for good old UNIX systems that are very vendor dependent.
But on Linux systems, `\cmd{uname}' will only display the Linux kernel name,
possibly with the kernel version. And as we know, we will have many
different Linux distributions, which can be very different from each other.
And how can we adapt to this diversity?

One of the possibilities is the lsb\_release command:\\
{\bf \struct{lsb\_release}}~--- provides certain \struct{LSB} (Linux Standard Base) and
distribution-specific information. The Linux Standard Base (LSB) is a joint
project by several Linux distributions under the organizational structure of
the Linux Foundation to standardize the software system structure, including
the Filesystem Hierarchy Standard used in the Linux kernel. The LSB is based on
the POSIX specification, the Single UNIX Specification (SUS),
and several other open standards, but extends them in certain areas.

\subsection*{Date}

Good. We get information about ``where''. Let's try to figure out ``when''.

{\bf\struct{date}}~--- print the system date and time. What time?
The current time of our time zone. We can check the time in a different time
zone, for example, Greenwich Mean Time (GMT):
\begin{code}{mverb}
$ TZ=GMT date
\end{code} % $
We can also set the current computer time:
\begin{code}{mverb}
$ man date
...
date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]
...
\end{code} % $

Also you can choose a different output format for time and date using the
`\cmd{+}' option:
\begin{code}{mverb}
date [OPTION]... [+FORMAT]
\end{code}
and use this command to convert from different time representations using
the `\cmd{--date}' option. You can find more details on the man page.

And of course we can see the calendar:
\begin{code}{mverb}
$ man cal
...
cal - displays a calendar
...
\end{code} % $

For example, the calendar for the first year of the UNIX epoch:
\begin{code}{mverb}
$ cal 1970
\end{code} % $

\subsection*{Users information commands}

Okay~--- `what', `when', but what about `who'? As we discussed earlier~---
we know that users and groups are just some magic numbers. Let's look at
the user's info:
\begin{code}{mverb}
id - print real and effective user and group IDs
\end{code}
But also we have yet another command:
\begin{code}{mverb}
logname - print user's login name
\end{code}
For what needs can we use this command if we already have an `\cmd{id}' command?
First of all: as far as we remember, we have different users, moreover,
different types of users. Let's look\ldots This is a regular user session.
The username is ``user''. Let's look to `\cmd{id}' command. And this is
the session of the root user. He, as we remember, is the superuser.
And we see absolutely another result of the id command. But ``\cmd{logname}''
will show the same result in both cases, just because we are logged in with
the user named ``\struct{user}'' in both sessions, and then switched
to superuser with the ``\cmd{sudo}'' or ``\cmd{su}'' command.
This can be important in some cases, and you can use this command
to determine the real user \struct{ID}.

\subsection*{Multiuser environment}

As we recall, a UNIX-like system is a multi-user environment,
and we have many utilities for working with such a system.

{\bf\struct{who}}~--- show who is logged on

{\bf\struct{finger}}~--- user information lookup program~--- more informative
command including user downtime. At this point, it can be understood that
a particular user is still sitting at his workplace or has left for coffee.
Moreover, we can see the user's status on other computers. But in this case,
you must understand that this is a client-server application.
You must have a server part on the computer that you requested,
and you need the appropriate privileges.

If you find the required user in the list of computer users, you can send
him a message manually or from the program using the ``\cmd{write}'' command:
\begin{code}{mverb}
write - send a message to another user
\end{code}
Just enter something and finish your message with EOF (\struct{\^{}D} as we
remember). In this command, we can select the terminal line to write.

\subsection*{Terminal line control}

And we can get our current terminal line using the `\cmd{tty}' command:
\begin{code}{mverb}
tty - print the file name of the terminal connected
       to standard input
\end{code}

We also have `\cmd{stty}' command to print and change terminal line settings.
With the option `\cmd{-a | --all}' we can get all the current driver settings of
this terminal line. And then we can change these settings with this command.
For example, the previously discussed setting of the Delete key
to interrupt a program on some older UNIX systems.

Another note about older UNIX systems is that stty on such systems may not
have the `\cmd{-F}' option. But we still have the option to select
the device~--- just by redirecting stdin:
\begin{code}{mverb}
stty < /dev/tty0
\end{code}

\section*{Processes}
%by Oleg Sadov — last modified Aug 21, 2020 05:00 PM

\subsection*{Process}

We've discussed the users, and then it's appropriate to talk about
another of the three whales of UNIX-like systems~--- processes. We can get
information about the processes by running the ``\cmd{ps}'' (process status)
command. In this case, we again see two worlds~--- two systems SYSV and BSD:
\begin{code}{mverb}
SYSV - ps [-efl]
BSD - ps [-][alx]
\end{code}

What about GNU? As we can see, GNU ps supports both sets of options with
some long options.

By default \cmd{ps} without options shows only process started by me and
connected to my current terminal line.

To get the status for all processes, we must use:
\begin{code}{mverb}
SYSV - ps -ef
BSD - ps ax
\end{code}

And we can get more information about the processes using the ``long'' options:
\begin{code}{mverb}
SYSV - ps -l
BSD - ps l
\end{code}

What information about the processes can we see?
\begin{description}
\item[{\bf\struct{UID}}]~--- effective user ID. A process can have a different
identifier than the user running the application because, as we will see
later, there is a mechanism in UNIX-like systems to change the identifier
on the run.
\item[{\bf\struct{PID}}]~--- a number representing the unique identifier of the process.
\item[{\bf\struct{PPID}}]~--- parent process ID. As we remember, We have a
hierarchical system of processes, and each process has its own parent. We
can see this hierarchy for example by such options set:
\begin{code}{mverb}
ps axjf | less
\end{code}
or just by command:
\begin{code}{mverb}
pstree
\end{code}
\item[{\bf\struct{PRI}}]~--- priority of the process. Higher number means lower
priority. But, as we will discuss later, we cannot change the priority,
because this value is dynamically changed by the process scheduler. And
we can only send recommendations to the scheduler using the 'nice' (NI)
parameter:
\item[{\bf\struct{NI}}]~--- can be set with 'nice' and 'renice' commands
\item[{\bf\struct{TTY}}]~--- controlling tty (terminal).
\item[{\bf\struct{CMD}}]~--- and the command.
\end{description}

And also a very useful (especially if the system hangs) command `\cmd{top}',
which dynamically displays information about processes, sorted
accordingly by the use of system resources~--- memory and CPU time.

{\bf\cmd{nice}}~--- run a program with modified scheduling priority.
`\struct{Nice}' value is just an integer. The smallest number means
the highest priority. The nice's range can be different on different systems
and you should look at the ``\cmd{man nice}'' on your system. In the case of
Linux nice value~--- between -20 and 19. Only the superuser can increase
the priority, the normal user can just decrease the default, which can be seen
by invoking the ``\cmd{nice}'' command with no arguments.

For example:
\begin{code}{mverb}
nice -n 19 command args...
\end{code}
means execution of the command with the lowest priority. This can be useful
for reducing the activity of non-interactive applications, such as the backup
process, which can slow down the interactive response of the system.

{\bf\cmd{renice}}~--- alter priority of running processes by PID. In this
case, you may not use the `\cmd{-n}' option~--- just a `nice' number.
For example:
\begin{code}{mverb}
renice 19 PID...
\end{code}

\subsection*{Jobs}

At the Shell level, we can use the `jobs' mechanism.

The easiest way to start a new background job is to use the ampersand:
\begin{code}{mverb}
gedit &
xeyes
\end{code}

Once the command is running, we can disconnect from the terminal line and
pause it by pressing '\cmd{\^{}Z}'. As we can see, the eyes do not move now.

We can see background and suspended jobs using the jobs command:
\begin{code}{mverb}
jobs
\end{code}

In the first position of the jobs list, we see the job number. We can use
this job number with a percent sign in front of it.

A suspended task, we can switch it to the background execution mode. By
default~--- current job:
\begin{code}{mverb}
bg [%jobN] - resume suspended job jobN in the background
\end{code}
and reattach the background job to the terminal line by bringing it to
the foreground:
\begin{code}{mverb}
fg [%jobN] - resume suspended job jobN in the foreground
\end{code}
After that we can interrupt the foreground job by pressing `\cmd{\^{}C}'.

\subsection*{Signals}

Another way to terminate a process is with the `\cmd{kill}' command:
\begin{code}{mverb}
kill %job
\end{code}
also you can kill the process by PID number:
\begin{code}{mverb}
kill [-s sigspec | -n signum | -sigspec] [pid | jobspec] ...
\end{code}

But in some cases `kill' does not work~--- for example, if the process is
frozen. We can fix this problem by calling another kill, just because
kill is actually sending a signal to the process, and we just have to
choose a different signal.
\begin{code}{mverb}
kill -l -- list of signals
\end{code}

\begin{itemize}
\item[15)] \cmd{SIGTERM}~-- generic signal used to cause program termination
(default kill)\\
\item[2)] \cmd{SIGINT}~--- ``program interrupt'' (INTR key~--- usually Ctrl-C)
\item[9)] \cmd{SIGKILL}~--- immediate program termination (cannot be blocked,
handled or ignored)
\item[1)] \cmd{SIGHUP}~--- terminal line is disconnected (often used for daemons
config rereading)
\item[3)] \cmd{SIGQUIT}~--- core dump process (QUIT key -- usually C-\textbackslash)
\end{itemize}

\subsection*{Offline execution}

When you execute a Unix job in the background ( using \cmd{\&}, \cmd{bg} command),
and logout from the session, your process will get killed.
We can avoid this using nohup command:

{\bf\struct{nohup}}~--- run a command immune to hangups,
with output to `nohup.out'

Another very useful program is `\cmd{screen}'~--- it's screen manager with
VT100/ANSI terminal emulation which supports multi-screen session support
with offline execution. In fact, you can run some long running commands
on multiple screen sessions and after disconnecting from this terminal
line with your hands or after breaking connecting. After that, you can
reconnect to this screen and you will see that all processes are still running.

\subsection*{Later execution and scheduled commands}

Another possibility of offline executing commands is later execution and
scheduled commands.

{\bf\struct{at}}, {\bf\struct{batch}}, {\bf\struct{atq}}, {\bf\struct{atrm}}~---
queue, examine or delete jobs for later execution

{\bf\struct{crontab}}~--- maintain crontab files for individual users
\end{document}
