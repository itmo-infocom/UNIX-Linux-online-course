\section*{Xserver} % ## Xserver

OK. Let's look to some classical XWindow applications.

The first one as we know is a X server:
\begin{code}{mverb}
man X
\end{code}

Most important options:
\begin{itemize}
\item\cmd{:displaynumber}~--- default is 0
\item\cmd{-fp fontPath}~--- search path for fonts
\item\cmd{-s minutes}~--- screen-saver timeout time in minutes
\end{itemize}

And some options that can help organize a local XWindow network with
low-cost X terminals and application servers:
\begin{itemize}
\item \cmd{-query hostname}~--- enables XDMCP and sends Query packets to
      the specified hostname on which this or that display manager is running;
\item \cmd{-broadcast}~--- enables XDMCP and broadcasts BroadcastQuery packets
      to the network. In this way, simple load balancing between application
      servers can be organized.
\item \cmd{-indirect hostname}~--- enables XDMCP and send IndirectQuery packets
      to the specified hostname. In this case, you will see a list of available
      application servers that you can select.
\end{itemize}

\subsection*{Xserver settings} % ## Xserver settings

After starting the X-server, it is possible to change some parameters
on the fly by `\cmd{xset}' command:
\begin{code}{mverb}
man xset - user preference utility for X
\end{code}

\noindent
Options:\\
\cmd{-display display}~--- set display\\
\cmd{q}~--- current settings\\
\cmd{[+|-]fp[+|-|=] path,...}~--- set the font path for X-server, including
    font-server\\
\cmd{fp default}~--- font path to be reset to the serverâ€™s default.\\
\cmd{fp rehash}~--- reset the font path to its current value (server reread
    the font databases in the current font path)\\
\cmd{p}~--- pixel color values\\
\cmd{s}~--- screen saver parameters


\subsection*{X-Window utiltities} % ## X-Window utiltities

As we discussed earlier, the main principle of the X Window System is
``Provide a mechanism, not a policy.'' And the look and feel in X Window
can be anything~--- it is simply determined by the set of widgets on which
a particular application is built. It is not a paradox, but the appearance of
the original XWindow applications may seem a little odd to modern users,
as they are based on an ancient set of widgets from the Athena project.
It looks ``ugly'' at now days, but they were often used in the period of
X history that he describes as the ``GUI wars'', as a safe alternative to
the competing Motif and Open Look toolkits.

Let's look at the well-known for us `\cmd{xterm}' application:
\begin{code}{mverb}
xterm
\end{code}{mverb}

As we can see, these are very simple 2D graphics with very unusual scrollbar
behavior, which often discourages new users. The general abstraction of
a mouse pointer in an XWindow is a three-button device. If you have a mouse
with fewer buttons, the middle button is emulated, for example,
by simultaneously pressing the left and right buttons. So here: pressing
the left button on the scroll bar scrolls forward, the right button backward,
and the middle button scrolls to the selected position.

Yet another classic XWindow utilities:
\begin{itemize}
\item[]\cmd{xkill}~--- kill a client by its X resource
\item[]\cmd{xdpyinfo}~--- display information utility for X
\item[]\cmd{xwininfo}~--- window information utility for X
\item[]\cmd{xlsclients}~--- list client applications running on a display
\item[]\cmd{showrgb}~--- display an rgb color-name database
\item[]\cmd{appres}~--- list X application resource database
\item[]\cmd{xrdb}~--- X server resource database utility
\item[]\cmd{editres}~--- a dynamic resource editor for X Toolkit applications
\item[]\cmd{xsetroot}~--- root window parameter setting utility for X
\item[]\cmd{xev}~--- print contents of X events
\item[]\cmd{xmodmap}~--- utility for modifying keymaps and pointer button mappings in X
\item[]\cmd{setxkbmap}~--- set the keyboard using the X Keyboard Extension
\item[]\cmd{xrefresh}~--- refresh all or part of an X screen
\end{itemize}
and others.
